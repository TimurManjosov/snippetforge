1de7ff8dc308bc6c9f3627d53e899a5d
"use strict";
// test/unit/guards/roles.guard.spec.ts
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const roles_guard_1 = require("../../../src/modules/auth/guards/roles.guard");
const mocks_1 = require("../../mocks");
const test_utils_1 = require("../../setup/test-utils");
/**
 * RolesGuard Unit Tests
 *
 * Testet:
 * - Routes ohne @Roles() sind für alle erlaubt
 * - Routes mit @Roles() erfordern passende Rolle
 * - Fehlende Rolle führt zu ForbiddenException
 */
describe('RolesGuard', () => {
    let guard;
    let reflector;
    beforeEach(() => {
        reflector = (0, mocks_1.createMockReflector)();
        guard = new roles_guard_1.RolesGuard(reflector);
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe('canActivate', () => {
        describe('when no roles are required', () => {
            it('should return true for any user', () => {
                // Arrange
                reflector.getAllAndOverride.mockReturnValue(undefined);
                const user = (0, mocks_1.createMockSafeUser)({ role: 'USER' });
                const context = (0, test_utils_1.createMockExecutionContext)({
                    request: { user },
                });
                // Act
                const result = guard.canActivate(context);
                // Assert
                expect(result).toBe(true);
            });
            it('should return true when roles array is empty', () => {
                // Arrange
                reflector.getAllAndOverride.mockReturnValue([]);
                const user = (0, mocks_1.createMockSafeUser)({ role: 'USER' });
                const context = (0, test_utils_1.createMockExecutionContext)({
                    request: { user },
                });
                // Act
                const result = guard.canActivate(context);
                // Assert
                expect(result).toBe(true);
            });
        });
        describe('when roles are required', () => {
            it('should return true when user has required role', () => {
                // Arrange
                reflector.getAllAndOverride.mockReturnValue(['ADMIN']);
                const user = (0, mocks_1.createMockSafeUser)({ role: 'ADMIN' });
                const context = (0, test_utils_1.createMockExecutionContext)({
                    request: { user },
                });
                // Act
                const result = guard.canActivate(context);
                // Assert
                expect(result).toBe(true);
            });
            it('should return true when user has one of multiple allowed roles', () => {
                // Arrange
                reflector.getAllAndOverride.mockReturnValue(['ADMIN', 'MODERATOR']);
                const user = (0, mocks_1.createMockSafeUser)({ role: 'MODERATOR' });
                const context = (0, test_utils_1.createMockExecutionContext)({
                    request: { user },
                });
                // Act
                const result = guard.canActivate(context);
                // Assert
                expect(result).toBe(true);
            });
            it('should throw ForbiddenException when user lacks required role', () => {
                // Arrange
                reflector.getAllAndOverride.mockReturnValue(['ADMIN']);
                const user = (0, mocks_1.createMockSafeUser)({ role: 'USER' });
                const context = (0, test_utils_1.createMockExecutionContext)({
                    request: { user },
                });
                // Act & Assert
                expect(() => guard.canActivate(context)).toThrow(common_1.ForbiddenException);
            });
            it('should throw ForbiddenException when no user in request', () => {
                // Arrange
                reflector.getAllAndOverride.mockReturnValue(['ADMIN']);
                const context = (0, test_utils_1.createMockExecutionContext)({
                    request: { user: undefined },
                });
                // Act & Assert
                expect(() => guard.canActivate(context)).toThrow(common_1.ForbiddenException);
            });
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aW11clxcUHJvZ3JhbW1pbmdcXFByb2plY3RzXFxzbmlwcGV0Zm9yZ2VcXGFwcHNcXGFwaVxcdGVzdFxcdW5pdFxcZ3VhcmRzXFxyb2xlcy5ndWFyZC5zcGVjLnRzIiwibWFwcGluZ3MiOiI7QUFBQSx1Q0FBdUM7O0FBRXZDLDJDQUFzRTtBQUV0RSw4RUFBMEU7QUFDMUUsdUNBQXNFO0FBQ3RFLHVEQUFvRTtBQUVwRTs7Ozs7OztHQU9HO0FBQ0gsUUFBUSxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUU7SUFDMUIsSUFBSSxLQUFpQixDQUFDO0lBQ3RCLElBQUksU0FBaUQsQ0FBQztJQUV0RCxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsU0FBUyxHQUFHLElBQUEsMkJBQW1CLEdBQUUsQ0FBQztRQUNsQyxLQUFLLEdBQUcsSUFBSSx3QkFBVSxDQUFDLFNBQWlDLENBQUMsQ0FBQztJQUM1RCxDQUFDLENBQUMsQ0FBQztJQUVILFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDYixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsYUFBYSxFQUFFLEdBQUcsRUFBRTtRQUMzQixRQUFRLENBQUMsNEJBQTRCLEVBQUUsR0FBRyxFQUFFO1lBQzFDLEVBQUUsQ0FBQyxpQ0FBaUMsRUFBRSxHQUFHLEVBQUU7Z0JBQ3pDLFVBQVU7Z0JBQ1YsU0FBUyxDQUFDLGlCQUFpQixDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDdkQsTUFBTSxJQUFJLEdBQUcsSUFBQSwwQkFBa0IsRUFBQyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRCxNQUFNLE9BQU8sR0FBRyxJQUFBLHVDQUEwQixFQUFDO29CQUN6QyxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUU7aUJBQ2xCLENBQWdDLENBQUM7Z0JBRWxDLE1BQU07Z0JBQ04sTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMs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LENBQUMsT0FBTyxDQUFDLDJCQUFrQixDQUFDLENBQUM7WUFDdkUsQ0FBQyxDQUFDLENBQUM7WUFFSCxFQUFFLENBQUMseURBQXlELEVBQUUsR0FBRyxFQUFFO2dCQUNqRSxVQUFVO2dCQUNWLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxlQUFlLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLE9BQU8sR0FBRyxJQUFBLHVDQUEwQixFQUFDO29CQUN6QyxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFO2lCQUM3QixDQUFnQyxDQUFDO2dCQUVsQyxlQUFlO2dCQUNmLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLDJCQUFrQixDQUFDLENBQUM7WUFDdkUsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0aW11clxcUHJvZ3JhbW1pbmdcXFByb2plY3RzXFxzbmlwcGV0Zm9yZ2VcXGFwcHNcXGFwaVxcdGVzdFxcdW5pdFxcZ3VhcmRzXFxyb2xlcy5ndWFyZC5zcGVjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRlc3QvdW5pdC9ndWFyZHMvcm9sZXMuZ3VhcmQuc3BlYy50c1xyXG5cclxuaW1wb3J0IHsgRXhlY3V0aW9uQ29udGV4dCwgRm9yYmlkZGVuRXhjZXB0aW9uIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xyXG5pbXBvcnQgeyBSZWZsZWN0b3IgfSBmcm9tICdAbmVzdGpzL2NvcmUnO1xyXG5pbXBvcnQgeyBSb2xlc0d1YXJkIH0gZnJvbSAnLi4vLi4vLi4vc3JjL21vZHVsZXMvYXV0aC9ndWFyZHMvcm9sZXMuZ3VhcmQnO1xyXG5pbXBvcnQgeyBjcmVhdGVNb2NrUmVmbGVjdG9yLCBjcmVhdGVNb2NrU2FmZVVzZXIgfSBmcm9tICcuLi8uLi9tb2Nrcyc7XHJcbmltcG9ydCB7IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0IH0gZnJvbSAnLi4vLi4vc2V0dXAvdGVzdC11dGlscyc7XHJcblxyXG4vKipcclxuICogUm9sZXNHdWFyZCBVbml0IFRlc3RzXHJcbiAqXHJcbiAqIFRlc3RldDpcclxuICogLSBSb3V0ZXMgb2huZSBAUm9sZXMoKSBzaW5kIGbDvHIgYWxsZSBlcmxhdWJ0XHJcbiAqIC0gUm91dGVzIG1pdCBAUm9sZXMoKSBlcmZvcmRlcm4gcGFzc2VuZGUgUm9sbGVcclxuICogLSBGZWhsZW5kZSBSb2xsZSBmw7xocnQgenUgRm9yYmlkZGVuRXhjZXB0aW9uXHJcbiAqL1xyXG5kZXNjcmliZSgnUm9sZXNHdWFyZCcsICgpID0+IHtcclxuICBsZXQgZ3VhcmQ6IFJvbGVzR3VhcmQ7XHJcbiAgbGV0IHJlZmxlY3RvcjogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlTW9ja1JlZmxlY3Rvcj47XHJcblxyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgcmVmbGVjdG9yID0gY3JlYXRlTW9ja1JlZmxlY3RvcigpO1xyXG4gICAgZ3VhcmQgPSBuZXcgUm9sZXNHdWFyZChyZWZsZWN0b3IgYXMgdW5rbm93biBhcyBSZWZsZWN0b3IpO1xyXG4gIH0pO1xyXG5cclxuICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdjYW5BY3RpdmF0ZScsICgpID0+IHtcclxuICAgIGRlc2NyaWJlKCd3aGVuIG5vIHJvbGVzIGFyZSByZXF1aXJlZCcsICgpID0+IHtcclxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBmb3IgYW55IHVzZXInLCAoKSA9PiB7XHJcbiAgICAgICAgLy8gQXJyYW5nZVxyXG4gICAgICAgIHJlZmxlY3Rvci5nZXRBbGxBbmRPdmVycmlkZS5tb2NrUmV0dXJuVmFsdWUodW5kZWZpbmVkKTtcclxuICAgICAgICBjb25zdCB1c2VyID0gY3JlYXRlTW9ja1NhZmVVc2VyKHsgcm9sZTogJ1VTRVInIH0pO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVNb2NrRXhlY3V0aW9uQ29udGV4dCh7XHJcbiAgICAgICAgICByZXF1ZXN0OiB7IHVzZXIgfSxcclxuICAgICAgICB9KSBhcyB1bmtub3duIGFzIEV4ZWN1dGlvbkNvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vIEFjdFxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xyXG5cclxuICAgICAgICAvLyBBc3NlcnRcclxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiByb2xlcyBhcnJheSBpcyBlbXB0eScsICgpID0+IHtcclxuICAgICAgICAvLyBBcnJhbmdlXHJcbiAgICAgICAgcmVmbGVjdG9yLmdldEFsbEFuZE92ZXJyaWRlLm1vY2tSZXR1cm5WYWx1ZShbXSk7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZU1vY2tTYWZlVXNlcih7IHJvbGU6ICdVU0VSJyB9KTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQoe1xyXG4gICAgICAgICAgcmVxdWVzdDogeyB1c2VyIH0sXHJcbiAgICAgICAgfSkgYXMgdW5rbm93biBhcyBFeGVjdXRpb25Db250ZXh0O1xyXG5cclxuICAgICAgICAvLyBBY3RcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBndWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gQXNzZXJ0XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiByb2xlcyBhcmUgcmVxdWlyZWQnLCAoKSA9PiB7XHJcbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB1c2VyIGhhcyByZXF1aXJlZCByb2xlJywgKCkgPT4ge1xyXG4gICAgICAgIC8vIEFycmFuZ2VcclxuICAgICAgICByZWZsZWN0b3IuZ2V0QWxsQW5kT3ZlcnJpZGUubW9ja1JldHVyblZhbHVlKFsnQURNSU4nXSk7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IGNyZWF0ZU1vY2tTYWZlVXNlcih7IHJvbGU6ICdBRE1JTicgfSk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHtcclxuICAgICAgICAgIHJlcXVlc3Q6IHsgdXNlciB9LFxyXG4gICAgICAgIH0pIGFzIHVua25vd24gYXMgRXhlY3V0aW9uQ29udGV4dDtcclxuXHJcbiAgICAgICAgLy8gQWN0XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZ3VhcmQuY2FuQWN0aXZhdGUoY29udGV4dCk7XHJcblxyXG4gICAgICAgIC8vIEFzc2VydFxyXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHVzZXIgaGFzIG9uZSBvZiBtdWx0aXBsZSBhbGxvd2VkIHJvbGVzJywgKCkgPT4ge1xyXG4gICAgICAgIC8vIEFycmFuZ2VcclxuICAgICAgICByZWZsZWN0b3IuZ2V0QWxsQW5kT3ZlcnJpZGUubW9ja1JldHVyblZhbHVlKFsnQURNSU4nLCAnTU9ERVJBVE9SJ10pO1xyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVNb2NrU2FmZVVzZXIoeyByb2xlOiAnTU9ERVJBVE9SJyB9KTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQoe1xyXG4gICAgICAgICAgcmVxdWVzdDogeyB1c2VyIH0sXHJcbiAgICAgICAgfSkgYXMgdW5rbm93biBhcyBFeGVjdXRpb25Db250ZXh0O1xyXG5cclxuICAgICAgICAvLyBBY3RcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBndWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KTtcclxuXHJcbiAgICAgICAgLy8gQXNzZXJ0XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnc2hvdWxkIHRocm93IEZvcmJpZGRlbkV4Y2VwdGlvbiB3aGVuIHVzZXIgbGFja3MgcmVxdWlyZWQgcm9sZScsICgpID0+IHtcclxuICAgICAgICAvLyBBcnJhbmdlXHJcbiAgICAgICAgcmVmbGVjdG9yLmdldEFsbEFuZE92ZXJyaWRlLm1vY2tSZXR1cm5WYWx1ZShbJ0FETUlOJ10pO1xyXG4gICAgICAgIGNvbnN0IHVzZXIgPSBjcmVhdGVNb2NrU2FmZVVzZXIoeyByb2xlOiAnVVNFUicgfSk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KHtcclxuICAgICAgICAgIHJlcXVlc3Q6IHsgdXNlciB9LFxyXG4gICAgICAgIH0pIGFzIHVua25vd24gYXMgRXhlY3V0aW9uQ29udGV4dDtcclxuXHJcbiAgICAgICAgLy8gQWN0ICYgQXNzZXJ0XHJcbiAgICAgICAgZXhwZWN0KCgpID0+IGd1YXJkLmNhbkFjdGl2YXRlKGNvbnRleHQpKS50b1Rocm93KEZvcmJpZGRlbkV4Y2VwdGlvbik7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3Nob3VsZCB0aHJvdyBGb3JiaWRkZW5FeGNlcHRpb24gd2hlbiBubyB1c2VyIGluIHJlcXVlc3QnLCAoKSA9PiB7XHJcbiAgICAgICAgLy8gQXJyYW5nZVxyXG4gICAgICAgIHJlZmxlY3Rvci5nZXRBbGxBbmRPdmVycmlkZS5tb2NrUmV0dXJuVmFsdWUoWydBRE1JTiddKTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlTW9ja0V4ZWN1dGlvbkNvbnRleHQoe1xyXG4gICAgICAgICAgcmVxdWVzdDogeyB1c2VyOiB1bmRlZmluZWQgfSxcclxuICAgICAgICB9KSBhcyB1bmtub3duIGFzIEV4ZWN1dGlvbkNvbnRleHQ7XHJcblxyXG4gICAgICAgIC8vIEFjdCAmIEFzc2VydFxyXG4gICAgICAgIGV4cGVjdCgoKSA9PiBndWFyZC5jYW5BY3RpdmF0ZShjb250ZXh0KSkudG9UaHJvdyhGb3JiaWRkZW5FeGNlcHRpb24pO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl0sInZlcnNpb24iOjN9