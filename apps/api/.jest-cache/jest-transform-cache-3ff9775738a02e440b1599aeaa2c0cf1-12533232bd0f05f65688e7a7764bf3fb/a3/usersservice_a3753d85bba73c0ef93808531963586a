924b4e7b29b3ed2a9b83f5b6a4fd9c7c
"use strict";
// src/modules/users/users.service.ts
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UsersService_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersService = void 0;
const common_1 = require("@nestjs/common");
const bcrypt = __importStar(require("bcryptjs"));
const users_repository_1 = require("./users.repository");
const users_types_1 = require("./users.types");
/**
 * UsersService - Business Logic für User-Operationen
 *
 * VERANTWORTLICHKEITEN (Single Responsibility):
 * - Password Hashing/Verification
 * - Business Rules (z.B. "Email muss unique sein")
 * - Koordination zwischen Repository und anderen Services
 * - Transformation (DB-Entity → SafeUser)
 *
 * WAS HIER NICHT PASSIERT:
 * - Direkte DB-Queries (→ Repository)
 * - HTTP Response Formatting (→ Controller)
 * - Input Validation (→ Zod Pipes)
 *
 * SECURITY:
 * - Passwords werden HIER gehasht, nicht im Repository
 * - passwordHash wird NIE nach außen gegeben (SafeUser)
 * - Timing-Safe Comparison bei Password-Checks
 */
// Bcrypt Konfiguration
// 10 Rounds = ~100ms pro Hash auf modernem CPU
// Guter Kompromiss zwischen Security und Performance
const BCRYPT_ROUNDS = 10;
let UsersService = UsersService_1 = class UsersService {
    usersRepository;
    logger = new common_1.Logger(UsersService_1.name);
    constructor(usersRepository) {
        this.usersRepository = usersRepository;
    }
    // ============================================================
    // PASSWORD HASHING
    // ============================================================
    /**
     * Hasht ein Klartext-Passwort mit bcrypt
     *
     * WARUM bcrypt?
     * - CPU-bound (verhindert GPU-Brute-Force)
     * - Eingebautes Salting (jeder Hash ist unique)
     * - Industrie-Standard seit >10 Jahren
     *
     * WARUM 10 Rounds?
     * - <10:  Zu schnell, leichter zu bruteforcen
     * - >12: Zu langsam, schlechte UX bei Login
     * - 10: ~100ms, guter Kompromiss
     *
     * @param password - Klartext-Passwort
     * @returns Gehashtes Passwort (60 Zeichen)
     */
    async hashPassword(password) {
        return bcrypt.hash(password, BCRYPT_ROUNDS);
    }
    /**
     * Vergleicht Klartext-Passwort mit Hash
     *
     * SECURITY: bcrypt. compare ist timing-safe
     * (verhindert Timing-Attacks)
     *
     * @param password - Klartext-Passwort vom User
     * @param hash - Gespeicherter Hash aus DB
     * @returns true wenn Match, false wenn nicht
     */
    async comparePassword(password, hash) {
        return bcrypt.compare(password, hash);
    }
    // ============================================================
    // USER CRUD OPERATIONS
    // ============================================================
    /**
     * Erstellt neuen User
     *
     * BUSINESS RULES:
     * 1. Email muss unique sein
     * 2. Username muss unique sein
     * 3. Password wird gehasht gespeichert
     *
     * @param data - CreateUserData (email, username, password)
     * @returns SafeUser (ohne passwordHash!)
     * @throws ConflictException wenn Email/Username existiert
     */
    async create(data) {
        this.logger.debug(`Creating user: ${data.email}`);
        // Normalize email for case-insensitive comparison and storage consistency
        const normalizedEmail = data.email.toLowerCase();
        // 1. Prüfe ob Email oder Username bereits existieren
        const existingUser = await this.usersRepository.findByEmailOrUsername(normalizedEmail, data.username);
        if (existingUser) {
            // Spezifische Fehlermeldung (aber nicht zu spezifisch - Security!)
            if (existingUser.email === normalizedEmail) {
                throw new common_1.ConflictException('Email is already registered');
            }
            throw new common_1.ConflictException('Username is already taken');
        }
        // 2. Password hashen
        const passwordHash = await this.hashPassword(data.password);
        // 3. User erstellen
        const user = await this.usersRepository.create({
            email: normalizedEmail,
            username: data.username,
            passwordHash,
        });
        this.logger.log(`User created: ${user.id}`);
        // 4. SafeUser zurückgeben (OHNE passwordHash!)
        return (0, users_types_1.toSafeUser)(user);
    }
    /**
     * Findet User anhand der ID
     * Gibt SafeUser zurück (ohne passwordHash)
     *
     * @param id - UUID des Users
     * @returns SafeUser
     * @throws NotFoundException wenn User nicht existiert
     */
    async findById(id) {
        const user = await this.usersRepository.findById(id);
        if (!user) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        return (0, users_types_1.toSafeUser)(user);
    }
    /**
     * Findet User anhand der Email
     * Gibt FullUser zurück (MIT passwordHash)
     *
     * NUR FÜR AUTHENTICATION VERWENDEN!
     * Niemals in API Response zurückgeben!
     *
     * @param email - Email-Adresse
     * @returns FullUser oder null wenn nicht gefunden
     */
    async findByEmailWithPassword(email) {
        const user = await this.usersRepository.findByEmail(email);
        if (!user) {
            return null;
        }
        return (0, users_types_1.toFullUser)(user);
    }
    /**
     * Findet User anhand der Email
     * Gibt SafeUser zurück (ohne passwordHash)
     *
     * @param email - Email-Adresse
     * @returns SafeUser
     * @throws NotFoundException wenn User nicht existiert
     */
    async findByEmail(email) {
        const user = await this.usersRepository.findByEmail(email);
        if (!user) {
            throw new common_1.NotFoundException(`User with email ${email} not found`);
        }
        return (0, users_types_1.toSafeUser)(user);
    }
    /**
     * Aktualisiert User-Profil
     *
     * @param id - UUID des Users
     * @param data - Zu aktualisierende Felder
     * @returns Aktualisierter SafeUser
     * @throws NotFoundException wenn User nicht existiert
     */
    async update(id, data) {
        this.logger.debug(`Updating user: ${id}`);
        // Prüfe ob User existiert
        const existingUser = await this.usersRepository.findById(id);
        if (!existingUser) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        // Prüfe ob Username bereits von anderem User verwendet wird
        if (data.username && data.username !== existingUser.username) {
            const userWithSameUsername = await this.usersRepository.findByUsername(data.username);
            if (userWithSameUsername && userWithSameUsername.id !== id) {
                throw new common_1.ConflictException('Username is already taken');
            }
        }
        // Update durchführen
        const updatedUser = await this.usersRepository.update(id, data);
        // Sollte nie null sein (wir haben gerade geprüft), aber Defensive Programming
        if (!updatedUser) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        this.logger.log(`User updated: ${id}`);
        return (0, users_types_1.toSafeUser)(updatedUser);
    }
    /**
     * Ändert User-Passwort
     *
     * SECURITY:
     * - Altes Passwort muss korrekt sein
     * - Neues Passwort wird gehasht
     *
     * @param id - UUID des Users
     * @param currentPassword - Aktuelles Passwort (Klartext)
     * @param newPassword - Neues Passwort (Klartext)
     * @returns true wenn erfolgreich
     * @throws NotFoundException wenn User nicht existiert
     * @throws ConflictException wenn aktuelles Passwort falsch
     */
    async changePassword(id, currentPassword, newPassword) {
        this.logger.debug(`Changing password for user: ${id}`);
        // 1. User mit passwordHash laden
        const user = await this.usersRepository.findById(id);
        if (!user) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        // 2. Aktuelles Passwort prüfen
        const isCurrentPasswordValid = await this.comparePassword(currentPassword, user.passwordHash);
        if (!isCurrentPasswordValid) {
            throw new common_1.ConflictException('Current password is incorrect');
        }
        // 3. Neues Passwort hashen und speichern
        const newPasswordHash = await this.hashPassword(newPassword);
        await this.usersRepository.updatePassword(id, newPasswordHash);
        this.logger.log(`Password changed for user: ${id}`);
        return true;
    }
    /**
     * Löscht User
     *
     * @param id - UUID des Users
     * @returns true wenn erfolgreich
     * @throws NotFoundException wenn User nicht existiert
     */
    async delete(id) {
        this.logger.debug(`Deleting user: ${id}`);
        const deleted = await this.usersRepository.delete(id);
        if (!deleted) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        this.logger.log(`User deleted: ${id}`);
        return true;
    }
    // ============================================================
    // VALIDATION HELPERS (für AuthService)
    // ============================================================
    /**
     * Validiert User-Credentials
     * Verwendet bei Login
     *
     * SECURITY:
     * - Gibt null zurück bei JEDEM Fehler (Email nicht gefunden ODER Password falsch)
     * - Verhindert User Enumeration
     *
     * @param email - Email-Adresse
     * @param password - Klartext-Passwort
     * @returns SafeUser wenn valide, null wenn nicht
     */
    async validateCredentials(email, password) {
        // 1. User laden (mit passwordHash)
        const user = await this.findByEmailWithPassword(email);
        if (!user) {
            // User nicht gefunden - aber wir verraten das nicht!
            // Stattdessen führen wir trotzdem einen Hash-Vergleich durch
            // (verhindert Timing-Attacks)
            // Real bcrypt hash (10 rounds) for consistent timing characteristics
            await this.comparePassword(password, '$2b$10$tfim3AUyYJJ.b1Cjz4jUn.NJ4JiCMCJYS7FotrpAKOAk2r6rjrQDe');
            return null;
        }
        // 2. Password vergleichen
        const isPasswordValid = await this.comparePassword(password, user.passwordHash);
        if (!isPasswordValid) {
            return null;
        }
        // 3. SafeUser zurückgeben (ohne passwordHash!)
        return (0, users_types_1.toSafeUser)(user);
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = UsersService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof users_repository_1.UsersRepository !== "undefined" && users_repository_1.UsersRepository) === "function" ? _a : Object])
], UsersService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aW11clxcUHJvZ3JhbW1pbmdcXFByb2plY3RzXFxzbmlwcGV0Zm9yZ2VcXGFwcHNcXGFwaVxcc3JjXFxtb2R1bGVzXFx1c2Vyc1xcdXNlcnMuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiO0FBQUEscUNBQXFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVyQywyQ0FLd0I7QUFDeEIsaURBQW1DO0FBQ25DLHlEQUFxRDtBQUNyRCwrQ0FPdUI7QUFFdkI7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUVILHVCQUF1QjtBQUN2QiwrQ0FBK0M7QUFDL0MscURBQXFEO0FBQ3JELE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUdsQixJQUFNLFlBQVksb0JBQWxCLE1BQU0sWUFBWTtJQUdNO0lBRlosTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLGNBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUV4RCxZQUE2QixlQUFnQztRQUFoQyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7SUFBRyxDQUFDO0lBRWpFLCtEQUErRDtJQUMvRCxtQkFBbUI7SUFDbkIsK0RBQStEO0lBRS9EOzs7Ozs7Ozs7Ozs7Ozs7T0FlRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQUMsUUFBZ0I7UUFDakMsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FBQyxRQUFnQixFQUFFLElBQVk7UUFDbEQsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRUQsK0RBQStEO0lBQy9ELHVCQUF1QjtJQUN2QiwrREFBK0Q7SUFFL0Q7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxLQUFLLENBQUMsTUFBTSxDQUFDLElBQW9CO1FBQy9CLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGtC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QUUvRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILEtBQUssQ0FBQyxtQkFBbUIsQ0FDdkIsS0FBYSxFQUNiLFFBQWdCO1FBRWhCLG1DQUFtQztRQUNuQyxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV2RCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDVixxREFBcUQ7WUFDckQsNkRBQTZEO1lBQzdELDhCQUE4QjtZQUM5QixxRUFBcUU7WUFDckUsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUN4QixRQUFRLEVBQ1IsOERBQThELENBQy9ELENBQUM7WUFDRixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCwwQkFBMEI7UUFDMUIsTUFBTSxlQUFlLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUNoRCxRQUFRLEVBQ1IsSUFBSSxDQUFDLFlBQVksQ0FDbEIsQ0FBQztRQUVGLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUNyQixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCwrQ0FBK0M7UUFDL0MsT0FBTyxJQUFBLHdCQUFVLEVBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUIsQ0FBQztDQUNGLENBQUE7QUEvU1ksb0NBQVk7dUJBQVosWUFBWTtJQUR4QixJQUFBLG1CQUFVLEdBQUU7eURBSW1DLGtDQUFlLG9CQUFmLGtDQUFlO0dBSGxELFlBQVksQ0ErU3hCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdGltdXJcXFByb2dyYW1taW5nXFxQcm9qZWN0c1xcc25pcHBldGZvcmdlXFxhcHBzXFxhcGlcXHNyY1xcbW9kdWxlc1xcdXNlcnNcXHVzZXJzLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL21vZHVsZXMvdXNlcnMvdXNlcnMuc2VydmljZS50c1xyXG5cclxuaW1wb3J0IHtcclxuICBDb25mbGljdEV4Y2VwdGlvbixcclxuICBJbmplY3RhYmxlLFxyXG4gIExvZ2dlcixcclxuICBOb3RGb3VuZEV4Y2VwdGlvbixcclxufSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XHJcbmltcG9ydCAqIGFzIGJjcnlwdCBmcm9tICdiY3J5cHRqcyc7XHJcbmltcG9ydCB7IFVzZXJzUmVwb3NpdG9yeSB9IGZyb20gJy4vdXNlcnMucmVwb3NpdG9yeSc7XHJcbmltcG9ydCB7XHJcbiAgdHlwZSBDcmVhdGVVc2VyRGF0YSxcclxuICB0eXBlIEZ1bGxVc2VyLFxyXG4gIHR5cGUgU2FmZVVzZXIsXHJcbiAgdHlwZSBVcGRhdGVVc2VyRGF0YSxcclxuICB0b0Z1bGxVc2VyLFxyXG4gIHRvU2FmZVVzZXIsXHJcbn0gZnJvbSAnLi91c2Vycy50eXBlcyc7XHJcblxyXG4vKipcclxuICogVXNlcnNTZXJ2aWNlIC0gQnVzaW5lc3MgTG9naWMgZsO8ciBVc2VyLU9wZXJhdGlvbmVuXHJcbiAqXHJcbiAqIFZFUkFOVFdPUlRMSUNIS0VJVEVOIChTaW5nbGUgUmVzcG9uc2liaWxpdHkpOlxyXG4gKiAtIFBhc3N3b3JkIEhhc2hpbmcvVmVyaWZpY2F0aW9uXHJcbiAqIC0gQnVzaW5lc3MgUnVsZXMgKHouQi4gXCJFbWFpbCBtdXNzIHVuaXF1ZSBzZWluXCIpXHJcbiAqIC0gS29vcmRpbmF0aW9uIHp3aXNjaGVuIFJlcG9zaXRvcnkgdW5kIGFuZGVyZW4gU2VydmljZXNcclxuICogLSBUcmFuc2Zvcm1hdGlvbiAoREItRW50aXR5IOKGkiBTYWZlVXNlcilcclxuICpcclxuICogV0FTIEhJRVIgTklDSFQgUEFTU0lFUlQ6XHJcbiAqIC0gRGlyZWt0ZSBEQi1RdWVyaWVzICjihpIgUmVwb3NpdG9yeSlcclxuICogLSBIVFRQIFJlc3BvbnNlIEZvcm1hdHRpbmcgKOKGkiBDb250cm9sbGVyKVxyXG4gKiAtIElucHV0IFZhbGlkYXRpb24gKOKGkiBab2QgUGlwZXMpXHJcbiAqXHJcbiAqIFNFQ1VSSVRZOlxyXG4gKiAtIFBhc3N3b3JkcyB3ZXJkZW4gSElFUiBnZWhhc2h0LCBuaWNodCBpbSBSZXBvc2l0b3J5XHJcbiAqIC0gcGFzc3dvcmRIYXNoIHdpcmQgTklFIG5hY2ggYXXDn2VuIGdlZ2ViZW4gKFNhZmVVc2VyKVxyXG4gKiAtIFRpbWluZy1TYWZlIENvbXBhcmlzb24gYmVpIFBhc3N3b3JkLUNoZWNrc1xyXG4gKi9cclxuXHJcbi8vIEJjcnlwdCBLb25maWd1cmF0aW9uXHJcbi8vIDEwIFJvdW5kcyA9IH4xMDBtcyBwcm8gSGFzaCBhdWYgbW9kZXJuZW0gQ1BVXHJcbi8vIEd1dGVyIEtvbXByb21pc3Mgendpc2NoZW4gU2VjdXJpdHkgdW5kIFBlcmZvcm1hbmNlXHJcbmNvbnN0IEJDUllQVF9ST1VORFMgPSAxMDtcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFVzZXJzU2VydmljZSB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dnZXIgPSBuZXcgTG9nZ2VyKFVzZXJzU2VydmljZS5uYW1lKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB1c2Vyc1JlcG9zaXRvcnk6IFVzZXJzUmVwb3NpdG9yeSkge31cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gUEFTU1dPUkQgSEFTSElOR1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAvKipcclxuICAgKiBIYXNodCBlaW4gS2xhcnRleHQtUGFzc3dvcnQgbWl0IGJjcnlwdFxyXG4gICAqXHJcbiAgICogV0FSVU0gYmNyeXB0P1xyXG4gICAqIC0gQ1BVLWJvdW5kICh2ZXJoaW5kZXJ0IEdQVS1CcnV0ZS1Gb3JjZSlcclxuICAgKiAtIEVpbmdlYmF1dGVzIFNhbHRpbmcgKGplZGVyIEhhc2ggaXN0IHVuaXF1ZSlcclxuICAgKiAtIEluZHVzdHJpZS1TdGFuZGFyZCBzZWl0ID4xMCBKYWhyZW5cclxuICAgKlxyXG4gICAqIFdBUlVNIDEwIFJvdW5kcz9cclxuICAgKiAtIDwxMDogIFp1IHNjaG5lbGwsIGxlaWNodGVyIHp1IGJydXRlZm9yY2VuXHJcbiAgICogLSA+MTI6IFp1IGxhbmdzYW0sIHNjaGxlY2h0ZSBVWCBiZWkgTG9naW5cclxuICAgKiAtIDEwOiB+MTAwbXMsIGd1dGVyIEtvbXByb21pc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSBwYXNzd29yZCAtIEtsYXJ0ZXh0LVBhc3N3b3J0XHJcbiAgICogQHJldHVybnMgR2VoYXNodGVzIFBhc3N3b3J0ICg2MCBaZWljaGVuKVxyXG4gICAqL1xyXG4gIGFzeW5jIGhhc2hQYXNzd29yZChwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIHJldHVybiBiY3J5cHQuaGFzaChwYXNzd29yZCwgQkNSWVBUX1JPVU5EUyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWZXJnbGVpY2h0IEtsYXJ0ZXh0LVBhc3N3b3J0IG1pdCBIYXNoXHJcbiAgICpcclxuICAgKiBTRUNVUklUWTogYmNyeXB0LiBjb21wYXJlIGlzdCB0aW1pbmctc2FmZVxyXG4gICAqICh2ZXJoaW5kZXJ0IFRpbWluZy1BdHRhY2tzKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHBhc3N3b3JkIC0gS2xhcnRleHQtUGFzc3dvcnQgdm9tIFVzZXJcclxuICAgKiBAcGFyYW0gaGFzaCAtIEdlc3BlaWNoZXJ0ZXIgSGFzaCBhdXMgREJcclxuICAgKiBAcmV0dXJucyB0cnVlIHdlbm4gTWF0Y2gsIGZhbHNlIHdlbm4gbmljaHRcclxuICAgKi9cclxuICBhc3luYyBjb21wYXJlUGFzc3dvcmQocGFzc3dvcmQ6IHN0cmluZywgaGFzaDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gYmNyeXB0LmNvbXBhcmUocGFzc3dvcmQsIGhhc2gpO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gVVNFUiBDUlVEIE9QRVJBVElPTlNcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgLyoqXHJcbiAgICogRXJzdGVsbHQgbmV1ZW4gVXNlclxyXG4gICAqXHJcbiAgICogQlVTSU5FU1MgUlVMRVM6XHJcbiAgICogMS4gRW1haWwgbXVzcyB1bmlxdWUgc2VpblxyXG4gICAqIDIuIFVzZXJuYW1lIG11c3MgdW5pcXVlIHNlaW5cclxuICAgKiAzLiBQYXNzd29yZCB3aXJkIGdlaGFzaHQgZ2VzcGVpY2hlcnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBkYXRhIC0gQ3JlYXRlVXNlckRhdGEgKGVtYWlsLCB1c2VybmFtZSwgcGFzc3dvcmQpXHJcbiAgICogQHJldHVybnMgU2FmZVVzZXIgKG9obmUgcGFzc3dvcmRIYXNoISlcclxuICAgKiBAdGhyb3dzIENvbmZsaWN0RXhjZXB0aW9uIHdlbm4gRW1haWwvVXNlcm5hbWUgZXhpc3RpZXJ0XHJcbiAgICovXHJcbiAgYXN5bmMgY3JlYXRlKGRhdGE6IENyZWF0ZVVzZXJEYXRhKTogUHJvbWlzZTxTYWZlVXNlcj4ge1xyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYENyZWF0aW5nIHVzZXI6ICR7ZGF0YS5lbWFpbH1gKTtcclxuXHJcbiAgICAvLyBOb3JtYWxpemUgZW1haWwgZm9yIGNhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvbiBhbmQgc3RvcmFnZSBjb25zaXN0ZW5jeVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZEVtYWlsID0gZGF0YS5lbWFpbC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIC8vIDEuIFByw7xmZSBvYiBFbWFpbCBvZGVyIFVzZXJuYW1lIGJlcmVpdHMgZXhpc3RpZXJlblxyXG4gICAgY29uc3QgZXhpc3RpbmdVc2VyID0gYXdhaXQgdGhpcy51c2Vyc1JlcG9zaXRvcnkuZmluZEJ5RW1haWxPclVzZXJuYW1lKFxyXG4gICAgICBub3JtYWxpemVkRW1haWwsXHJcbiAgICAgIGRhdGEudXNlcm5hbWUsXHJcbiAgICApO1xyXG5cclxuICAgIGlmIChleGlzdGluZ1VzZXIpIHtcclxuICAgICAgLy8gU3BlemlmaXNjaGUgRmVobGVybWVsZHVuZyAoYWJlciBuaWNodCB6dSBzcGV6aWZpc2NoIC0gU2VjdXJpdHkhKVxyXG4gICAgICBpZiAoZXhpc3RpbmdVc2VyLmVtYWlsID09PSBub3JtYWxpemVkRW1haWwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oJ0VtYWlsIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IG5ldyBDb25mbGljdEV4Y2VwdGlvbignVXNlcm5hbWUgaXMgYWxyZWFkeSB0YWtlbicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDIuIFBhc3N3b3JkIGhhc2hlblxyXG4gICAgY29uc3QgcGFzc3dvcmRIYXNoID0gYXdhaXQgdGhpcy5oYXNoUGFzc3dvcmQoZGF0YS5wYXNzd29yZCk7XHJcblxyXG4gICAgLy8gMy4gVXNlciBlcnN0ZWxsZW5cclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJzUmVwb3NpdG9yeS5jcmVhdGUoe1xyXG4gICAgICBlbWFpbDogbm9ybWFsaXplZEVtYWlsLFxyXG4gICAgICB1c2VybmFtZTogZGF0YS51c2VybmFtZSxcclxuICAgICAgcGFzc3dvcmRIYXNoLFxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5sb2dnZXIubG9nKGBVc2VyIGNyZWF0ZWQ6ICR7dXNlci5pZH1gKTtcclxuXHJcbiAgICAvLyA0LiBTYWZlVXNlciB6dXLDvGNrZ2ViZW4gKE9ITkUgcGFzc3dvcmRIYXNoISlcclxuICAgIHJldHVybiB0b1NhZmVVc2VyKHVzZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZGV0IFVzZXIgYW5oYW5kIGRlciBJRFxyXG4gICAqIEdpYnQgU2FmZVVzZXIgenVyw7xjayAob2huZSBwYXNzd29yZEhhc2gpXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWQgLSBVVUlEIGRlcyBVc2Vyc1xyXG4gICAqIEByZXR1cm5zIFNhZmVVc2VyXHJcbiAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiB3ZW5uIFVzZXIgbmljaHQgZXhpc3RpZXJ0XHJcbiAgICovXHJcbiAgYXN5bmMgZmluZEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8U2FmZVVzZXI+IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJzUmVwb3NpdG9yeS5maW5kQnlJZChpZCk7XHJcblxyXG4gICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgVXNlciB3aXRoIElEICR7aWR9IG5vdCBmb3VuZGApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b1NhZmVVc2VyKHVzZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZGV0IFVzZXIgYW5oYW5kIGRlciBFbWFpbFxyXG4gICAqIEdpYnQgRnVsbFVzZXIgenVyw7xjayAoTUlUIHBhc3N3b3JkSGFzaClcclxuICAgKlxyXG4gICAqIE5VUiBGw5xSIEFVVEhFTlRJQ0FUSU9OIFZFUldFTkRFTiFcclxuICAgKiBOaWVtYWxzIGluIEFQSSBSZXNwb25zZSB6dXLDvGNrZ2ViZW4hXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbC1BZHJlc3NlXHJcbiAgICogQHJldHVybnMgRnVsbFVzZXIgb2RlciBudWxsIHdlbm4gbmljaHQgZ2VmdW5kZW5cclxuICAgKi9cclxuICBhc3luYyBmaW5kQnlFbWFpbFdpdGhQYXNzd29yZChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTxGdWxsVXNlciB8IG51bGw+IHtcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJzUmVwb3NpdG9yeS5maW5kQnlFbWFpbChlbWFpbCk7XHJcblxyXG4gICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0b0Z1bGxVc2VyKHVzZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZGV0IFVzZXIgYW5oYW5kIGRlciBFbWFpbFxyXG4gICAqIEdpYnQgU2FmZVVzZXIgenVyw7xjayAob2huZSBwYXNzd29yZEhhc2gpXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbC1BZHJlc3NlXHJcbiAgICogQHJldHVybnMgU2FmZVVzZXJcclxuICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIHdlbm4gVXNlciBuaWNodCBleGlzdGllcnRcclxuICAgKi9cclxuICBhc3luYyBmaW5kQnlFbWFpbChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTxTYWZlVXNlcj4ge1xyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeUVtYWlsKGVtYWlsKTtcclxuXHJcbiAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uKGBVc2VyIHdpdGggZW1haWwgJHtlbWFpbH0gbm90IGZvdW5kYCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRvU2FmZVVzZXIodXNlcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBa3R1YWxpc2llcnQgVXNlci1Qcm9maWxcclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIFVVSUQgZGVzIFVzZXJzXHJcbiAgICogQHBhcmFtIGRhdGEgLSBadSBha3R1YWxpc2llcmVuZGUgRmVsZGVyXHJcbiAgICogQHJldHVybnMgQWt0dWFsaXNpZXJ0ZXIgU2FmZVVzZXJcclxuICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIHdlbm4gVXNlciBuaWNodCBleGlzdGllcnRcclxuICAgKi9cclxuICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZywgZGF0YTogVXBkYXRlVXNlckRhdGEpOiBQcm9taXNlPFNhZmVVc2VyPiB7XHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVXBkYXRpbmcgdXNlcjogJHtpZH1gKTtcclxuXHJcbiAgICAvLyBQcsO8ZmUgb2IgVXNlciBleGlzdGllcnRcclxuICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeUlkKGlkKTtcclxuICAgIGlmICghZXhpc3RpbmdVc2VyKSB7XHJcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgVXNlciB3aXRoIElEICR7aWR9IG5vdCBmb3VuZGApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByw7xmZSBvYiBVc2VybmFtZSBiZXJlaXRzIHZvbiBhbmRlcmVtIFVzZXIgdmVyd2VuZGV0IHdpcmRcclxuICAgIGlmIChkYXRhLnVzZXJuYW1lICYmIGRhdGEudXNlcm5hbWUgIT09IGV4aXN0aW5nVXNlci51c2VybmFtZSkge1xyXG4gICAgICBjb25zdCB1c2VyV2l0aFNhbWVVc2VybmFtZSA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeVVzZXJuYW1lKFxyXG4gICAgICAgIGRhdGEudXNlcm5hbWUsXHJcbiAgICAgICk7XHJcbiAgICAgIGlmICh1c2VyV2l0aFNhbWVVc2VybmFtZSAmJiB1c2VyV2l0aFNhbWVVc2VybmFtZS5pZCAhPT0gaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oJ1VzZXJuYW1lIGlzIGFscmVhZHkgdGFrZW4nKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBkdXJjaGbDvGhyZW5cclxuICAgIGNvbnN0IHVwZGF0ZWRVc2VyID0gYXdhaXQgdGhpcy51c2Vyc1JlcG9zaXRvcnkudXBkYXRlKGlkLCBkYXRhKTtcclxuXHJcbiAgICAvLyBTb2xsdGUgbmllIG51bGwgc2VpbiAod2lyIGhhYmVuIGdlcmFkZSBnZXByw7xmdCksIGFiZXIgRGVmZW5zaXZlIFByb2dyYW1taW5nXHJcbiAgICBpZiAoIXVwZGF0ZWRVc2VyKSB7XHJcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgVXNlciB3aXRoIElEICR7aWR9IG5vdCBmb3VuZGApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubG9nZ2VyLmxvZyhgVXNlciB1cGRhdGVkOiAke2lkfWApO1xyXG4gICAgcmV0dXJuIHRvU2FmZVVzZXIodXBkYXRlZFVzZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogw4RuZGVydCBVc2VyLVBhc3N3b3J0XHJcbiAgICpcclxuICAgKiBTRUNVUklUWTpcclxuICAgKiAtIEFsdGVzIFBhc3N3b3J0IG11c3Mga29ycmVrdCBzZWluXHJcbiAgICogLSBOZXVlcyBQYXNzd29ydCB3aXJkIGdlaGFzaHRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIFVVSUQgZGVzIFVzZXJzXHJcbiAgICogQHBhcmFtIGN1cnJlbnRQYXNzd29yZCAtIEFrdHVlbGxlcyBQYXNzd29ydCAoS2xhcnRleHQpXHJcbiAgICogQHBhcmFtIG5ld1Bhc3N3b3JkIC0gTmV1ZXMgUGFzc3dvcnQgKEtsYXJ0ZXh0KVxyXG4gICAqIEByZXR1cm5zIHRydWUgd2VubiBlcmZvbGdyZWljaFxyXG4gICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gd2VubiBVc2VyIG5pY2h0IGV4aXN0aWVydFxyXG4gICAqIEB0aHJvd3MgQ29uZmxpY3RFeGNlcHRpb24gd2VubiBha3R1ZWxsZXMgUGFzc3dvcnQgZmFsc2NoXHJcbiAgICovXHJcbiAgYXN5bmMgY2hhbmdlUGFzc3dvcmQoXHJcbiAgICBpZDogc3RyaW5nLFxyXG4gICAgY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsXHJcbiAgICBuZXdQYXNzd29yZDogc3RyaW5nLFxyXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYENoYW5naW5nIHBhc3N3b3JkIGZvciB1c2VyOiAke2lkfWApO1xyXG5cclxuICAgIC8vIDEuIFVzZXIgbWl0IHBhc3N3b3JkSGFzaCBsYWRlblxyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeUlkKGlkKTtcclxuICAgIGlmICghdXNlcikge1xyXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oYFVzZXIgd2l0aCBJRCAke2lkfSBub3QgZm91bmRgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAyLiBBa3R1ZWxsZXMgUGFzc3dvcnQgcHLDvGZlblxyXG4gICAgY29uc3QgaXNDdXJyZW50UGFzc3dvcmRWYWxpZCA9IGF3YWl0IHRoaXMuY29tcGFyZVBhc3N3b3JkKFxyXG4gICAgICBjdXJyZW50UGFzc3dvcmQsXHJcbiAgICAgIHVzZXIucGFzc3dvcmRIYXNoLFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIWlzQ3VycmVudFBhc3N3b3JkVmFsaWQpIHtcclxuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKCdDdXJyZW50IHBhc3N3b3JkIGlzIGluY29ycmVjdCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDMuIE5ldWVzIFBhc3N3b3J0IGhhc2hlbiB1bmQgc3BlaWNoZXJuXHJcbiAgICBjb25zdCBuZXdQYXNzd29yZEhhc2ggPSBhd2FpdCB0aGlzLmhhc2hQYXNzd29yZChuZXdQYXNzd29yZCk7XHJcbiAgICBhd2FpdCB0aGlzLnVzZXJzUmVwb3NpdG9yeS51cGRhdGVQYXNzd29yZChpZCwgbmV3UGFzc3dvcmRIYXNoKTtcclxuXHJcbiAgICB0aGlzLmxvZ2dlci5sb2coYFBhc3N3b3JkIGNoYW5nZWQgZm9yIHVzZXI6ICR7aWR9YCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEzDtnNjaHQgVXNlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlkIC0gVVVJRCBkZXMgVXNlcnNcclxuICAgKiBAcmV0dXJucyB0cnVlIHdlbm4gZXJmb2xncmVpY2hcclxuICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIHdlbm4gVXNlciBuaWNodCBleGlzdGllcnRcclxuICAgKi9cclxuICBhc3luYyBkZWxldGUoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYERlbGV0aW5nIHVzZXI6ICR7aWR9YCk7XHJcblxyXG4gICAgY29uc3QgZGVsZXRlZCA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmRlbGV0ZShpZCk7XHJcblxyXG4gICAgaWYgKCFkZWxldGVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgVXNlciB3aXRoIElEICR7aWR9IG5vdCBmb3VuZGApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubG9nZ2VyLmxvZyhgVXNlciBkZWxldGVkOiAke2lkfWApO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBWQUxJREFUSU9OIEhFTFBFUlMgKGbDvHIgQXV0aFNlcnZpY2UpXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkaWVydCBVc2VyLUNyZWRlbnRpYWxzXHJcbiAgICogVmVyd2VuZGV0IGJlaSBMb2dpblxyXG4gICAqXHJcbiAgICogU0VDVVJJVFk6XHJcbiAgICogLSBHaWJ0IG51bGwgenVyw7xjayBiZWkgSkVERU0gRmVobGVyIChFbWFpbCBuaWNodCBnZWZ1bmRlbiBPREVSIFBhc3N3b3JkIGZhbHNjaClcclxuICAgKiAtIFZlcmhpbmRlcnQgVXNlciBFbnVtZXJhdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwtQWRyZXNzZVxyXG4gICAqIEBwYXJhbSBwYXNzd29yZCAtIEtsYXJ0ZXh0LVBhc3N3b3J0XHJcbiAgICogQHJldHVybnMgU2FmZVVzZXIgd2VubiB2YWxpZGUsIG51bGwgd2VubiBuaWNodFxyXG4gICAqL1xyXG4gIGFzeW5jIHZhbGlkYXRlQ3JlZGVudGlhbHMoXHJcbiAgICBlbWFpbDogc3RyaW5nLFxyXG4gICAgcGFzc3dvcmQ6IHN0cmluZyxcclxuICApOiBQcm9taXNlPFNhZmVVc2VyIHwgbnVsbD4ge1xyXG4gICAgLy8gMS4gVXNlciBsYWRlbiAobWl0IHBhc3N3b3JkSGFzaClcclxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmZpbmRCeUVtYWlsV2l0aFBhc3N3b3JkKGVtYWlsKTtcclxuXHJcbiAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgLy8gVXNlciBuaWNodCBnZWZ1bmRlbiAtIGFiZXIgd2lyIHZlcnJhdGVuIGRhcyBuaWNodCFcclxuICAgICAgLy8gU3RhdHRkZXNzZW4gZsO8aHJlbiB3aXIgdHJvdHpkZW0gZWluZW4gSGFzaC1WZXJnbGVpY2ggZHVyY2hcclxuICAgICAgLy8gKHZlcmhpbmRlcnQgVGltaW5nLUF0dGFja3MpXHJcbiAgICAgIC8vIFJlYWwgYmNyeXB0IGhhc2ggKDEwIHJvdW5kcykgZm9yIGNvbnNpc3RlbnQgdGltaW5nIGNoYXJhY3RlcmlzdGljc1xyXG4gICAgICBhd2FpdCB0aGlzLmNvbXBhcmVQYXNzd29yZChcclxuICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICAnJDJiJDEwJHRmaW0zQVV5WUpKLmIxQ2p6NGpVbi5OSjRKaUNNQ0pZUzdGb3RycEFLT0FrMnI2cmpyUURlJyxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gMi4gUGFzc3dvcmQgdmVyZ2xlaWNoZW5cclxuICAgIGNvbnN0IGlzUGFzc3dvcmRWYWxpZCA9IGF3YWl0IHRoaXMuY29tcGFyZVBhc3N3b3JkKFxyXG4gICAgICBwYXNzd29yZCxcclxuICAgICAgdXNlci5wYXNzd29yZEhhc2gsXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghaXNQYXNzd29yZFZhbGlkKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDMuIFNhZmVVc2VyIHp1csO8Y2tnZWJlbiAob2huZSBwYXNzd29yZEhhc2ghKVxyXG4gICAgcmV0dXJuIHRvU2FmZVVzZXIodXNlcik7XHJcbiAgfVxyXG59XHJcbiJdLCJ2ZXJzaW9uIjozfQ==