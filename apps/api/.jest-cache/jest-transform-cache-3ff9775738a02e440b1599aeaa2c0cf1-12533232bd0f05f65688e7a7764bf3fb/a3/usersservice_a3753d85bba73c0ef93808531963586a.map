{"file":"C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\users\\users.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\users\\users.service.ts"],"sourcesContent":["// src/modules/users/users.service.ts\r\n\r\nimport {\r\n  ConflictException,\r\n  Injectable,\r\n  Logger,\r\n  NotFoundException,\r\n} from '@nestjs/common';\r\nimport * as bcrypt from 'bcryptjs';\r\nimport { UsersRepository } from './users.repository';\r\nimport {\r\n  type CreateUserData,\r\n  type FullUser,\r\n  type SafeUser,\r\n  type UpdateUserData,\r\n  toFullUser,\r\n  toSafeUser,\r\n} from './users.types';\r\n\r\n/**\r\n * UsersService - Business Logic für User-Operationen\r\n *\r\n * VERANTWORTLICHKEITEN (Single Responsibility):\r\n * - Password Hashing/Verification\r\n * - Business Rules (z.B. \"Email muss unique sein\")\r\n * - Koordination zwischen Repository und anderen Services\r\n * - Transformation (DB-Entity → SafeUser)\r\n *\r\n * WAS HIER NICHT PASSIERT:\r\n * - Direkte DB-Queries (→ Repository)\r\n * - HTTP Response Formatting (→ Controller)\r\n * - Input Validation (→ Zod Pipes)\r\n *\r\n * SECURITY:\r\n * - Passwords werden HIER gehasht, nicht im Repository\r\n * - passwordHash wird NIE nach außen gegeben (SafeUser)\r\n * - Timing-Safe Comparison bei Password-Checks\r\n */\r\n\r\n// Bcrypt Konfiguration\r\n// 10 Rounds = ~100ms pro Hash auf modernem CPU\r\n// Guter Kompromiss zwischen Security und Performance\r\nconst BCRYPT_ROUNDS = 10;\r\n\r\n@Injectable()\r\nexport class UsersService {\r\n  private readonly logger = new Logger(UsersService.name);\r\n\r\n  constructor(private readonly usersRepository: UsersRepository) {}\r\n\r\n  // ============================================================\r\n  // PASSWORD HASHING\r\n  // ============================================================\r\n\r\n  /**\r\n   * Hasht ein Klartext-Passwort mit bcrypt\r\n   *\r\n   * WARUM bcrypt?\r\n   * - CPU-bound (verhindert GPU-Brute-Force)\r\n   * - Eingebautes Salting (jeder Hash ist unique)\r\n   * - Industrie-Standard seit >10 Jahren\r\n   *\r\n   * WARUM 10 Rounds?\r\n   * - <10:  Zu schnell, leichter zu bruteforcen\r\n   * - >12: Zu langsam, schlechte UX bei Login\r\n   * - 10: ~100ms, guter Kompromiss\r\n   *\r\n   * @param password - Klartext-Passwort\r\n   * @returns Gehashtes Passwort (60 Zeichen)\r\n   */\r\n  async hashPassword(password: string): Promise<string> {\r\n    return bcrypt.hash(password, BCRYPT_ROUNDS);\r\n  }\r\n\r\n  /**\r\n   * Vergleicht Klartext-Passwort mit Hash\r\n   *\r\n   * SECURITY: bcrypt. compare ist timing-safe\r\n   * (verhindert Timing-Attacks)\r\n   *\r\n   * @param password - Klartext-Passwort vom User\r\n   * @param hash - Gespeicherter Hash aus DB\r\n   * @returns true wenn Match, false wenn nicht\r\n   */\r\n  async comparePassword(password: string, hash: string): Promise<boolean> {\r\n    return bcrypt.compare(password, hash);\r\n  }\r\n\r\n  // ============================================================\r\n  // USER CRUD OPERATIONS\r\n  // ============================================================\r\n\r\n  /**\r\n   * Erstellt neuen User\r\n   *\r\n   * BUSINESS RULES:\r\n   * 1. Email muss unique sein\r\n   * 2. Username muss unique sein\r\n   * 3. Password wird gehasht gespeichert\r\n   *\r\n   * @param data - CreateUserData (email, username, password)\r\n   * @returns SafeUser (ohne passwordHash!)\r\n   * @throws ConflictException wenn Email/Username existiert\r\n   */\r\n  async create(data: CreateUserData): Promise<SafeUser> {\r\n    this.logger.debug(`Creating user: ${data.email}`);\r\n\r\n    // Normalize email for case-insensitive comparison and storage consistency\r\n    const normalizedEmail = data.email.toLowerCase();\r\n\r\n    // 1. Prüfe ob Email oder Username bereits existieren\r\n    const existingUser = await this.usersRepository.findByEmailOrUsername(\r\n      normalizedEmail,\r\n      data.username,\r\n    );\r\n\r\n    if (existingUser) {\r\n      // Spezifische Fehlermeldung (aber nicht zu spezifisch - Security!)\r\n      if (existingUser.email === normalizedEmail) {\r\n        throw new ConflictException('Email is already registered');\r\n      }\r\n      throw new ConflictException('Username is already taken');\r\n    }\r\n\r\n    // 2. Password hashen\r\n    const passwordHash = await this.hashPassword(data.password);\r\n\r\n    // 3. User erstellen\r\n    const user = await this.usersRepository.create({\r\n      email: normalizedEmail,\r\n      username: data.username,\r\n      passwordHash,\r\n    });\r\n\r\n    this.logger.log(`User created: ${user.id}`);\r\n\r\n    // 4. SafeUser zurückgeben (OHNE passwordHash!)\r\n    return toSafeUser(user);\r\n  }\r\n\r\n  /**\r\n   * Findet User anhand der ID\r\n   * Gibt SafeUser zurück (ohne passwordHash)\r\n   *\r\n   * @param id - UUID des Users\r\n   * @returns SafeUser\r\n   * @throws NotFoundException wenn User nicht existiert\r\n   */\r\n  async findById(id: string): Promise<SafeUser> {\r\n    const user = await this.usersRepository.findById(id);\r\n\r\n    if (!user) {\r\n      throw new NotFoundException(`User with ID ${id} not found`);\r\n    }\r\n\r\n    return toSafeUser(user);\r\n  }\r\n\r\n  /**\r\n   * Findet User anhand der Email\r\n   * Gibt FullUser zurück (MIT passwordHash)\r\n   *\r\n   * NUR FÜR AUTHENTICATION VERWENDEN!\r\n   * Niemals in API Response zurückgeben!\r\n   *\r\n   * @param email - Email-Adresse\r\n   * @returns FullUser oder null wenn nicht gefunden\r\n   */\r\n  async findByEmailWithPassword(email: string): Promise<FullUser | null> {\r\n    const user = await this.usersRepository.findByEmail(email);\r\n\r\n    if (!user) {\r\n      return null;\r\n    }\r\n\r\n    return toFullUser(user);\r\n  }\r\n\r\n  /**\r\n   * Findet User anhand der Email\r\n   * Gibt SafeUser zurück (ohne passwordHash)\r\n   *\r\n   * @param email - Email-Adresse\r\n   * @returns SafeUser\r\n   * @throws NotFoundException wenn User nicht existiert\r\n   */\r\n  async findByEmail(email: string): Promise<SafeUser> {\r\n    const user = await this.usersRepository.findByEmail(email);\r\n\r\n    if (!user) {\r\n      throw new NotFoundException(`User with email ${email} not found`);\r\n    }\r\n\r\n    return toSafeUser(user);\r\n  }\r\n\r\n  /**\r\n   * Aktualisiert User-Profil\r\n   *\r\n   * @param id - UUID des Users\r\n   * @param data - Zu aktualisierende Felder\r\n   * @returns Aktualisierter SafeUser\r\n   * @throws NotFoundException wenn User nicht existiert\r\n   */\r\n  async update(id: string, data: UpdateUserData): Promise<SafeUser> {\r\n    this.logger.debug(`Updating user: ${id}`);\r\n\r\n    // Prüfe ob User existiert\r\n    const existingUser = await this.usersRepository.findById(id);\r\n    if (!existingUser) {\r\n      throw new NotFoundException(`User with ID ${id} not found`);\r\n    }\r\n\r\n    // Prüfe ob Username bereits von anderem User verwendet wird\r\n    if (data.username && data.username !== existingUser.username) {\r\n      const userWithSameUsername = await this.usersRepository.findByUsername(\r\n        data.username,\r\n      );\r\n      if (userWithSameUsername && userWithSameUsername.id !== id) {\r\n        throw new ConflictException('Username is already taken');\r\n      }\r\n    }\r\n\r\n    // Update durchführen\r\n    const updatedUser = await this.usersRepository.update(id, data);\r\n\r\n    // Sollte nie null sein (wir haben gerade geprüft), aber Defensive Programming\r\n    if (!updatedUser) {\r\n      throw new NotFoundException(`User with ID ${id} not found`);\r\n    }\r\n\r\n    this.logger.log(`User updated: ${id}`);\r\n    return toSafeUser(updatedUser);\r\n  }\r\n\r\n  /**\r\n   * Ändert User-Passwort\r\n   *\r\n   * SECURITY:\r\n   * - Altes Passwort muss korrekt sein\r\n   * - Neues Passwort wird gehasht\r\n   *\r\n   * @param id - UUID des Users\r\n   * @param currentPassword - Aktuelles Passwort (Klartext)\r\n   * @param newPassword - Neues Passwort (Klartext)\r\n   * @returns true wenn erfolgreich\r\n   * @throws NotFoundException wenn User nicht existiert\r\n   * @throws ConflictException wenn aktuelles Passwort falsch\r\n   */\r\n  async changePassword(\r\n    id: string,\r\n    currentPassword: string,\r\n    newPassword: string,\r\n  ): Promise<boolean> {\r\n    this.logger.debug(`Changing password for user: ${id}`);\r\n\r\n    // 1. User mit passwordHash laden\r\n    const user = await this.usersRepository.findById(id);\r\n    if (!user) {\r\n      throw new NotFoundException(`User with ID ${id} not found`);\r\n    }\r\n\r\n    // 2. Aktuelles Passwort prüfen\r\n    const isCurrentPasswordValid = await this.comparePassword(\r\n      currentPassword,\r\n      user.passwordHash,\r\n    );\r\n\r\n    if (!isCurrentPasswordValid) {\r\n      throw new ConflictException('Current password is incorrect');\r\n    }\r\n\r\n    // 3. Neues Passwort hashen und speichern\r\n    const newPasswordHash = await this.hashPassword(newPassword);\r\n    await this.usersRepository.updatePassword(id, newPasswordHash);\r\n\r\n    this.logger.log(`Password changed for user: ${id}`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Löscht User\r\n   *\r\n   * @param id - UUID des Users\r\n   * @returns true wenn erfolgreich\r\n   * @throws NotFoundException wenn User nicht existiert\r\n   */\r\n  async delete(id: string): Promise<boolean> {\r\n    this.logger.debug(`Deleting user: ${id}`);\r\n\r\n    const deleted = await this.usersRepository.delete(id);\r\n\r\n    if (!deleted) {\r\n      throw new NotFoundException(`User with ID ${id} not found`);\r\n    }\r\n\r\n    this.logger.log(`User deleted: ${id}`);\r\n    return true;\r\n  }\r\n\r\n  // ============================================================\r\n  // VALIDATION HELPERS (für AuthService)\r\n  // ============================================================\r\n\r\n  /**\r\n   * Validiert User-Credentials\r\n   * Verwendet bei Login\r\n   *\r\n   * SECURITY:\r\n   * - Gibt null zurück bei JEDEM Fehler (Email nicht gefunden ODER Password falsch)\r\n   * - Verhindert User Enumeration\r\n   *\r\n   * @param email - Email-Adresse\r\n   * @param password - Klartext-Passwort\r\n   * @returns SafeUser wenn valide, null wenn nicht\r\n   */\r\n  async validateCredentials(\r\n    email: string,\r\n    password: string,\r\n  ): Promise<SafeUser | null> {\r\n    // 1. User laden (mit passwordHash)\r\n    const user = await this.findByEmailWithPassword(email);\r\n\r\n    if (!user) {\r\n      // User nicht gefunden - aber wir verraten das nicht!\r\n      // Stattdessen führen wir trotzdem einen Hash-Vergleich durch\r\n      // (verhindert Timing-Attacks)\r\n      // Real bcrypt hash (10 rounds) for consistent timing characteristics\r\n      await this.comparePassword(\r\n        password,\r\n        '$2b$10$tfim3AUyYJJ.b1Cjz4jUn.NJ4JiCMCJYS7FotrpAKOAk2r6rjrQDe',\r\n      );\r\n      return null;\r\n    }\r\n\r\n    // 2. Password vergleichen\r\n    const isPasswordValid = await this.comparePassword(\r\n      password,\r\n      user.passwordHash,\r\n    );\r\n\r\n    if (!isPasswordValid) {\r\n      return null;\r\n    }\r\n\r\n    // 3. SafeUser zurückgeben (ohne passwordHash!)\r\n    return toSafeUser(user);\r\n  }\r\n}\r\n"],"version":3}