d54b280cad4f940535a9a6220e14888d
"use strict";
// src/modules/users/users.repository.ts
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UsersRepository_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersRepository = void 0;
const common_1 = require("@nestjs/common");
const drizzle_orm_1 = require("drizzle-orm");
const schema_1 = require("../../lib/db/schema");
const database_1 = require("../../shared/database");
/**
 * UsersRepository - Data Access Layer für User-Entity
 *
 * VERANTWORTLICHKEITEN (Single Responsibility):
 * - Alle Datenbank-Queries für Users
 * - Keine Business Logic (kein Hashing, keine Validation)
 * - Keine HTTP-Concerns (keine Exceptions werfen)
 *
 * WARUM Repository Pattern?
 * 1. Testbarkeit: Repository kann gemockt werden
 * 2. Austauschbarkeit: DB-Wechsel betrifft nur Repository
 * 3. Klarheit: Service enthält nur Business Logic
 *
 * RETURN VALUES:
 * - Gefunden: User-Objekt
 * - Nicht gefunden: null (NICHT undefined!)
 * - Fehler: Exception wird geworfen (DB-Errors)
 */
let UsersRepository = UsersRepository_1 = class UsersRepository {
    db;
    logger = new common_1.Logger(UsersRepository_1.name);
    constructor(db) {
        this.db = db;
    }
    /**
     * Findet User anhand der ID
     *
     * @param id - UUID des Users
     * @returns User oder null wenn nicht gefunden
     */
    async findById(id) {
        this.logger.debug(`Finding user by ID: ${id}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.eq)(schema_1.users.id, id),
        });
        return result ?? null;
    }
    /**
     * Findet User anhand der Email
     * Verwendet für Login und Email-Uniqueness-Check
     *
     * @param email - Email-Adresse (case-insensitive durch DB)
     * @returns User oder null wenn nicht gefunden
     */
    async findByEmail(email) {
        this.logger.debug(`Finding user by email: ${email}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.eq)(schema_1.users.email, email.toLowerCase()),
        });
        return result ?? null;
    }
    /**
     * Findet User anhand des Usernamens
     * Verwendet für Username-Uniqueness-Check
     *
     * @param username - Username (case-sensitive)
     * @returns User oder null wenn nicht gefunden
     */
    async findByUsername(username) {
        this.logger.debug(`Finding user by username: ${username}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.eq)(schema_1.users.username, username),
        });
        return result ?? null;
    }
    /**
     * Prüft ob Email ODER Username bereits existieren
     * Verwendet bei Registration um Duplikate zu verhindern
     *
     * @param email - Email zu prüfen
     * @param username - Username zu prüfen
     * @returns User wenn einer existiert, sonst null
     */
    async findByEmailOrUsername(email, username) {
        this.logger.debug(`Checking if email or username exists: ${email}, ${username}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.or)((0, drizzle_orm_1.eq)(schema_1.users.email, email.toLowerCase()), (0, drizzle_orm_1.eq)(schema_1.users.username, username)),
        });
        return result ?? null;
    }
    /**
     * Erstellt neuen User in der Datenbank
     *
     * WICHTIG:
     * - data.passwordHash muss BEREITS gehasht sein!
     * - Email wird automatisch lowercase gespeichert
     *
     * @param data - User-Daten (mit passwordHash, NICHT password!)
     * @returns Erstellter User
     * @throws Bei Constraint-Violation (Duplicate Email/Username)
     */
    async create(data) {
        this.logger.debug(`Creating new user: ${data.email}`);
        const [newUser] = await this.db.drizzle
            .insert(schema_1.users)
            .values({
            ...data,
            email: data.email.toLowerCase(), // Normalisierung
        })
            .returning();
        this.logger.log(`User created successfully: ${newUser.id}`);
        return newUser;
    }
    /**
     * Aktualisiert User-Daten
     *
     * @param id - UUID des Users
     * @param data - Zu aktualisierende Felder
     * @returns Aktualisierter User oder null wenn nicht gefunden
     */
    async update(id, data) {
        this.logger.debug(`Updating user: ${id}`);
        const [updatedUser] = await this.db.drizzle
            .update(schema_1.users)
            .set({
            ...data,
            updatedAt: new Date(), // Timestamp aktualisieren
        })
            .where((0, drizzle_orm_1.eq)(schema_1.users.id, id))
            .returning();
        if (!updatedUser) {
            this.logger.warn(`User not found for update: ${id}`);
            return null;
        }
        this.logger.log(`User updated successfully: ${id}`);
        return updatedUser;
    }
    /**
     * Aktualisiert nur das Passwort eines Users
     * Separatiert von update() für Klarheit und Audit-Logging
     *
     * @param id - UUID des Users
     * @param passwordHash - Neuer Password Hash (BEREITS gehasht!)
     * @returns true wenn erfolgreich, false wenn User nicht gefunden
     */
    async updatePassword(id, passwordHash) {
        this.logger.debug(`Updating password for user: ${id}`);
        const result = await this.db.drizzle
            .update(schema_1.users)
            .set({
            passwordHash,
            updatedAt: new Date(),
        })
            .where((0, drizzle_orm_1.eq)(schema_1.users.id, id))
            .returning({ id: schema_1.users.id });
        if (result.length === 0) {
            this.logger.warn(`User not found for password update: ${id}`);
            return false;
        }
        this.logger.log(`Password updated successfully for user: ${id}`);
        return true;
    }
    /**
     * Löscht User (Hard Delete)
     *
     * WARNUNG: In Production besser Soft Delete verwenden!
     * (isDeleted Flag statt echtem Löschen)
     *
     * @param id - UUID des Users
     * @returns true wenn gelöscht, false wenn nicht gefunden
     */
    async delete(id) {
        this.logger.debug(`Deleting user: ${id}`);
        const result = await this.db.drizzle
            .delete(schema_1.users)
            .where((0, drizzle_orm_1.eq)(schema_1.users.id, id))
            .returning({ id: schema_1.users.id });
        if (result.length === 0) {
            this.logger.warn(`User not found for deletion: ${id}`);
            return false;
        }
        this.logger.log(`User deleted successfully: ${id}`);
        return true;
    }
    /**
     * Zählt alle User (für Admin-Dashboard)
     *
     * @returns Anzahl der User
     */
    async count() {
        const result = await this.db.drizzle
            .select({ count: schema_1.users.id })
            .from(schema_1.users);
        // Drizzle gibt Array zurück, wir brauchen Länge
        return result.length;
    }
};
exports.UsersRepository = UsersRepository;
exports.UsersRepository = UsersRepository = UsersRepository_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof database_1.DatabaseService !== "undefined" && database_1.DatabaseService) === "function" ? _a : Object])
], UsersRepository);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aW11clxcUHJvZ3JhbW1pbmdcXFByb2plY3RzXFxzbmlwcGV0Zm9yZ2VcXGFwcHNcXGFwaVxcc3JjXFxtb2R1bGVzXFx1c2Vyc1xcdXNlcnMucmVwb3NpdG9yeS50cyIsIm1hcHBpbmdzIjoiO0FBQUEsd0NBQXdDOzs7Ozs7Ozs7Ozs7OztBQUV4QywyQ0FBb0Q7QUFDcEQsNkNBQXFDO0FBQ3JDLGdEQUFxRTtBQUNyRSxvREFBd0Q7QUFFeEQ7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBRUksSUFBTSxlQUFlLHVCQUFyQixNQUFNLGVBQWU7SUFHRztJQUZaLE1BQU0sR0FBRyxJQUFJLGVBQU0sQ0FBQyxpQkFBZSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRTNELFlBQTZCLEVBQW1CO1FBQW5CLE9BQUUsR0FBRixFQUFFLENBQWlCO0lBQUcsQ0FBQztJQUVwRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBVTtRQUN2QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUUvQyxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO1lBQ3pELEtBQUssRUFBRSxJQUFBLGdCQUFFLEVBQUMsY0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7U0FDeEIsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLElBQUksSUFBSSxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQWE7UUFDN0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsMEJBQTBCLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFckQsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztZQUN6RCxLQUFLLEVBQUUsSUFBQSxnQkFBRSxFQUFDLGNBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzVDLENBQUMsQ0FBQztRQUVILE9BQU8sTUFBTSxJQUFJLElBQUksQ0FBQztJQUN4QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxDQUFDLGNBQWMsQ0FBQyxRQUFnQjtRQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUUzRCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO1lBQ3pELEtBQUssRUFBRSxJQUFBLGdCQUFFLEVBQUMsY0FBSyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUM7U0FDcEMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLElBQUksSUFBSSxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsS0FBSyxDQUFDLHFCQUFxQixDQUN6QixLQUFhLEVBQ2IsUUFBZ0I7UUFFaEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQ2YseUNBQXlDLEtBQUssS0FBSyxRQUFRLEVBQUUsQ0FDOUQsQ0FBQztRQUVGLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7WUFDekQsS0FBSyxFQUFFLElBQUEsZ0JBQUUsRUFDUCxJQUFBLGdCQUFFLEVBQUMsY0FBSyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsRUFDcEMsSUFBQSxnQkFBRSxFQUFDLGNBQUssQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQzdCO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsT0FBTyxNQUFNLElBQUksSUFBSSxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0gsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFhO1FBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHNCQUFzQixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUV0RCxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU87YUFDcEMsTUFBTSxDQUFDLGNBQUssQ0FBQzthQUNiLE1BQU0sQ0FBQztZQUNOLEdBQUcsSUFBSTtZQUNQLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxFQUFFLGlCQUFpQjtTQUNuRCxDQUFDO2FBQ0QsU0FBUyxFQUFFLENBQUM7UUFFZixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyw4QkFBOEIsT0FBTyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDNUQsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBVSxFQUFFLElBQXNCO1FBQzdDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLGtCQUFrQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRTFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTzthQUN4QyxNQUFNLENBQUMsY0FBSyxDQUFDO2FBQ2IsR0FBRyxDQUFDO1lBQ0gsR0FBRyxJQUFJO1lBQ1AsU0FBUyxFQUFFLElBQUksSUFBSSxFQUFFLEVBQUUsMEJBQTBCO1NBQ2xELENBQUM7YUFDRCxLQUFLLENBQUMsSUFBQSxnQkFBRSxFQUFDLGNBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7YUFDdkIsU0FBUyxFQUFFLENBQUM7UUFFZixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsOEJBQThCLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDckQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsOEJBQThCLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEQsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsY0FBYyxDQUFDLEVBQVUsRUFBRSxZQUFvQjtRQUNuRCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQywrQkFBK0IsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV2RCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTzthQUNqQyxNQUFNLENBQUMsY0FBSyxDQUFDO2FBQ2IsR0FBRyxDQUFDO1lBQ0gsWUFBWTtZQUNaLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTtTQUN0QixDQUFDO2FBQ0QsS0FBSyxDQUFDLElBQUEsZ0JBQUUsRUFBQyxjQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZCLFNBQVMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxjQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUUvQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsdUNBQXVDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDOUQsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsMkNBQTJDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDakUsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQVU7UUFDckIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFMUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU87YUFDakMsTUFBTSxDQUFDLGNBQUssQ0FBQzthQUNiLEtBQUssQ0FBQyxJQUFBLGdCQUFFLEVBQUMsY0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUN2QixTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsY0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFL0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdDQUFnQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZELE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLDhCQUE4QixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsS0FBSztRQUNULE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPO2FBQ2pDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxjQUFLLENBQUMsRUFBRSxFQUFFLENBQUM7YUFDM0IsSUFBSSxDQUFDLGNBQUssQ0FBQyxDQUFDO1FBRWYsZ0RBQWdEO1FBQ2hELE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUN2QixDQUFDO0NBQ0YsQ0FBQTtBQTNNWSwwQ0FBZTswQkFBZixlQUFlO0lBRDNCLElBQUEsbUJBQVUsR0FBRTt5REFJc0IsMEJBQWUsb0JBQWYsMEJBQWU7R0FIckMsZUFBZSxDQTJNM0IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0aW11clxcUHJvZ3JhbW1pbmdcXFByb2plY3RzXFxzbmlwcGV0Zm9yZ2VcXGFwcHNcXGFwaVxcc3JjXFxtb2R1bGVzXFx1c2Vyc1xcdXNlcnMucmVwb3NpdG9yeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbW9kdWxlcy91c2Vycy91c2Vycy5yZXBvc2l0b3J5LnRzXHJcblxyXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBMb2dnZXIgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XHJcbmltcG9ydCB7IGVxLCBvciB9IGZyb20gJ2RyaXp6bGUtb3JtJztcclxuaW1wb3J0IHsgdXNlcnMsIHR5cGUgTmV3VXNlciwgdHlwZSBVc2VyIH0gZnJvbSAnLi4vLi4vbGliL2RiL3NjaGVtYSc7XHJcbmltcG9ydCB7IERhdGFiYXNlU2VydmljZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9kYXRhYmFzZSc7XHJcblxyXG4vKipcclxuICogVXNlcnNSZXBvc2l0b3J5IC0gRGF0YSBBY2Nlc3MgTGF5ZXIgZsO8ciBVc2VyLUVudGl0eVxyXG4gKlxyXG4gKiBWRVJBTlRXT1JUTElDSEtFSVRFTiAoU2luZ2xlIFJlc3BvbnNpYmlsaXR5KTpcclxuICogLSBBbGxlIERhdGVuYmFuay1RdWVyaWVzIGbDvHIgVXNlcnNcclxuICogLSBLZWluZSBCdXNpbmVzcyBMb2dpYyAoa2VpbiBIYXNoaW5nLCBrZWluZSBWYWxpZGF0aW9uKVxyXG4gKiAtIEtlaW5lIEhUVFAtQ29uY2VybnMgKGtlaW5lIEV4Y2VwdGlvbnMgd2VyZmVuKVxyXG4gKlxyXG4gKiBXQVJVTSBSZXBvc2l0b3J5IFBhdHRlcm4/XHJcbiAqIDEuIFRlc3RiYXJrZWl0OiBSZXBvc2l0b3J5IGthbm4gZ2Vtb2NrdCB3ZXJkZW5cclxuICogMi4gQXVzdGF1c2NoYmFya2VpdDogREItV2VjaHNlbCBiZXRyaWZmdCBudXIgUmVwb3NpdG9yeVxyXG4gKiAzLiBLbGFyaGVpdDogU2VydmljZSBlbnRow6RsdCBudXIgQnVzaW5lc3MgTG9naWNcclxuICpcclxuICogUkVUVVJOIFZBTFVFUzpcclxuICogLSBHZWZ1bmRlbjogVXNlci1PYmpla3RcclxuICogLSBOaWNodCBnZWZ1bmRlbjogbnVsbCAoTklDSFQgdW5kZWZpbmVkISlcclxuICogLSBGZWhsZXI6IEV4Y2VwdGlvbiB3aXJkIGdld29yZmVuIChEQi1FcnJvcnMpXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBVc2Vyc1JlcG9zaXRvcnkge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9nZ2VyID0gbmV3IExvZ2dlcihVc2Vyc1JlcG9zaXRvcnkubmFtZSk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZGI6IERhdGFiYXNlU2VydmljZSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZGV0IFVzZXIgYW5oYW5kIGRlciBJRFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlkIC0gVVVJRCBkZXMgVXNlcnNcclxuICAgKiBAcmV0dXJucyBVc2VyIG9kZXIgbnVsbCB3ZW5uIG5pY2h0IGdlZnVuZGVuXHJcbiAgICovXHJcbiAgYXN5bmMgZmluZEJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGaW5kaW5nIHVzZXIgYnkgSUQ6ICR7aWR9YCk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kYi5kcml6emxlLnF1ZXJ5LnVzZXJzLmZpbmRGaXJzdCh7XHJcbiAgICAgIHdoZXJlOiBlcSh1c2Vycy5pZCwgaWQpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdCA/PyBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZGV0IFVzZXIgYW5oYW5kIGRlciBFbWFpbFxyXG4gICAqIFZlcndlbmRldCBmw7xyIExvZ2luIHVuZCBFbWFpbC1VbmlxdWVuZXNzLUNoZWNrXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbC1BZHJlc3NlIChjYXNlLWluc2Vuc2l0aXZlIGR1cmNoIERCKVxyXG4gICAqIEByZXR1cm5zIFVzZXIgb2RlciBudWxsIHdlbm4gbmljaHQgZ2VmdW5kZW5cclxuICAgKi9cclxuICBhc3luYyBmaW5kQnlFbWFpbChlbWFpbDogc3RyaW5nKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xyXG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYEZpbmRpbmcgdXNlciBieSBlbWFpbDogJHtlbWFpbH1gKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGUucXVlcnkudXNlcnMuZmluZEZpcnN0KHtcclxuICAgICAgd2hlcmU6IGVxKHVzZXJzLmVtYWlsLCBlbWFpbC50b0xvd2VyQ2FzZSgpKSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQgPz8gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRldCBVc2VyIGFuaGFuZCBkZXMgVXNlcm5hbWVuc1xyXG4gICAqIFZlcndlbmRldCBmw7xyIFVzZXJuYW1lLVVuaXF1ZW5lc3MtQ2hlY2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB1c2VybmFtZSAtIFVzZXJuYW1lIChjYXNlLXNlbnNpdGl2ZSlcclxuICAgKiBAcmV0dXJucyBVc2VyIG9kZXIgbnVsbCB3ZW5uIG5pY2h0IGdlZnVuZGVuXHJcbiAgICovXHJcbiAgYXN5bmMgZmluZEJ5VXNlcm5hbWUodXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGaW5kaW5nIHVzZXIgYnkgdXNlcm5hbWU6ICR7dXNlcm5hbWV9YCk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kYi5kcml6emxlLnF1ZXJ5LnVzZXJzLmZpbmRGaXJzdCh7XHJcbiAgICAgIHdoZXJlOiBlcSh1c2Vycy51c2VybmFtZSwgdXNlcm5hbWUpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdCA/PyBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHLDvGZ0IG9iIEVtYWlsIE9ERVIgVXNlcm5hbWUgYmVyZWl0cyBleGlzdGllcmVuXHJcbiAgICogVmVyd2VuZGV0IGJlaSBSZWdpc3RyYXRpb24gdW0gRHVwbGlrYXRlIHp1IHZlcmhpbmRlcm5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIHp1IHByw7xmZW5cclxuICAgKiBAcGFyYW0gdXNlcm5hbWUgLSBVc2VybmFtZSB6dSBwcsO8ZmVuXHJcbiAgICogQHJldHVybnMgVXNlciB3ZW5uIGVpbmVyIGV4aXN0aWVydCwgc29uc3QgbnVsbFxyXG4gICAqL1xyXG4gIGFzeW5jIGZpbmRCeUVtYWlsT3JVc2VybmFtZShcclxuICAgIGVtYWlsOiBzdHJpbmcsXHJcbiAgICB1c2VybmFtZTogc3RyaW5nLFxyXG4gICk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKFxyXG4gICAgICBgQ2hlY2tpbmcgaWYgZW1haWwgb3IgdXNlcm5hbWUgZXhpc3RzOiAke2VtYWlsfSwgJHt1c2VybmFtZX1gLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGUucXVlcnkudXNlcnMuZmluZEZpcnN0KHtcclxuICAgICAgd2hlcmU6IG9yKFxyXG4gICAgICAgIGVxKHVzZXJzLmVtYWlsLCBlbWFpbC50b0xvd2VyQ2FzZSgpKSxcclxuICAgICAgICBlcSh1c2Vycy51c2VybmFtZSwgdXNlcm5hbWUpLFxyXG4gICAgICApLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdCA/PyBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRXJzdGVsbHQgbmV1ZW4gVXNlciBpbiBkZXIgRGF0ZW5iYW5rXHJcbiAgICpcclxuICAgKiBXSUNIVElHOlxyXG4gICAqIC0gZGF0YS5wYXNzd29yZEhhc2ggbXVzcyBCRVJFSVRTIGdlaGFzaHQgc2VpbiFcclxuICAgKiAtIEVtYWlsIHdpcmQgYXV0b21hdGlzY2ggbG93ZXJjYXNlIGdlc3BlaWNoZXJ0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gZGF0YSAtIFVzZXItRGF0ZW4gKG1pdCBwYXNzd29yZEhhc2gsIE5JQ0hUIHBhc3N3b3JkISlcclxuICAgKiBAcmV0dXJucyBFcnN0ZWxsdGVyIFVzZXJcclxuICAgKiBAdGhyb3dzIEJlaSBDb25zdHJhaW50LVZpb2xhdGlvbiAoRHVwbGljYXRlIEVtYWlsL1VzZXJuYW1lKVxyXG4gICAqL1xyXG4gIGFzeW5jIGNyZWF0ZShkYXRhOiBOZXdVc2VyKTogUHJvbWlzZTxVc2VyPiB7XHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQ3JlYXRpbmcgbmV3IHVzZXI6ICR7ZGF0YS5lbWFpbH1gKTtcclxuXHJcbiAgICBjb25zdCBbbmV3VXNlcl0gPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGVcclxuICAgICAgLmluc2VydCh1c2VycylcclxuICAgICAgLnZhbHVlcyh7XHJcbiAgICAgICAgLi4uZGF0YSxcclxuICAgICAgICBlbWFpbDogZGF0YS5lbWFpbC50b0xvd2VyQ2FzZSgpLCAvLyBOb3JtYWxpc2llcnVuZ1xyXG4gICAgICB9KVxyXG4gICAgICAucmV0dXJuaW5nKCk7XHJcblxyXG4gICAgdGhpcy5sb2dnZXIubG9nKGBVc2VyIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5OiAke25ld1VzZXIuaWR9YCk7XHJcbiAgICByZXR1cm4gbmV3VXNlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFrdHVhbGlzaWVydCBVc2VyLURhdGVuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWQgLSBVVUlEIGRlcyBVc2Vyc1xyXG4gICAqIEBwYXJhbSBkYXRhIC0gWnUgYWt0dWFsaXNpZXJlbmRlIEZlbGRlclxyXG4gICAqIEByZXR1cm5zIEFrdHVhbGlzaWVydGVyIFVzZXIgb2RlciBudWxsIHdlbm4gbmljaHQgZ2VmdW5kZW5cclxuICAgKi9cclxuICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZywgZGF0YTogUGFydGlhbDxOZXdVc2VyPik6IFByb21pc2U8VXNlciB8IG51bGw+IHtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBVcGRhdGluZyB1c2VyOiAke2lkfWApO1xyXG5cclxuICAgIGNvbnN0IFt1cGRhdGVkVXNlcl0gPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGVcclxuICAgICAgLnVwZGF0ZSh1c2VycylcclxuICAgICAgLnNldCh7XHJcbiAgICAgICAgLi4uZGF0YSxcclxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksIC8vIFRpbWVzdGFtcCBha3R1YWxpc2llcmVuXHJcbiAgICAgIH0pXHJcbiAgICAgIC53aGVyZShlcSh1c2Vycy5pZCwgaWQpKVxyXG4gICAgICAucmV0dXJuaW5nKCk7XHJcblxyXG4gICAgaWYgKCF1cGRhdGVkVXNlcikge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBVc2VyIG5vdCBmb3VuZCBmb3IgdXBkYXRlOiAke2lkfWApO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxvZ2dlci5sb2coYFVzZXIgdXBkYXRlZCBzdWNjZXNzZnVsbHk6ICR7aWR9YCk7XHJcbiAgICByZXR1cm4gdXBkYXRlZFVzZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBa3R1YWxpc2llcnQgbnVyIGRhcyBQYXNzd29ydCBlaW5lcyBVc2Vyc1xyXG4gICAqIFNlcGFyYXRpZXJ0IHZvbiB1cGRhdGUoKSBmw7xyIEtsYXJoZWl0IHVuZCBBdWRpdC1Mb2dnaW5nXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWQgLSBVVUlEIGRlcyBVc2Vyc1xyXG4gICAqIEBwYXJhbSBwYXNzd29yZEhhc2ggLSBOZXVlciBQYXNzd29yZCBIYXNoIChCRVJFSVRTIGdlaGFzaHQhKVxyXG4gICAqIEByZXR1cm5zIHRydWUgd2VubiBlcmZvbGdyZWljaCwgZmFsc2Ugd2VubiBVc2VyIG5pY2h0IGdlZnVuZGVuXHJcbiAgICovXHJcbiAgYXN5bmMgdXBkYXRlUGFzc3dvcmQoaWQ6IHN0cmluZywgcGFzc3dvcmRIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBVcGRhdGluZyBwYXNzd29yZCBmb3IgdXNlcjogJHtpZH1gKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGVcclxuICAgICAgLnVwZGF0ZSh1c2VycylcclxuICAgICAgLnNldCh7XHJcbiAgICAgICAgcGFzc3dvcmRIYXNoLFxyXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgfSlcclxuICAgICAgLndoZXJlKGVxKHVzZXJzLmlkLCBpZCkpXHJcbiAgICAgIC5yZXR1cm5pbmcoeyBpZDogdXNlcnMuaWQgfSk7XHJcblxyXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhpcy5sb2dnZXIud2FybihgVXNlciBub3QgZm91bmQgZm9yIHBhc3N3b3JkIHVwZGF0ZTogJHtpZH1gKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubG9nZ2VyLmxvZyhgUGFzc3dvcmQgdXBkYXRlZCBzdWNjZXNzZnVsbHkgZm9yIHVzZXI6ICR7aWR9YCk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEzDtnNjaHQgVXNlciAoSGFyZCBEZWxldGUpXHJcbiAgICpcclxuICAgKiBXQVJOVU5HOiBJbiBQcm9kdWN0aW9uIGJlc3NlciBTb2Z0IERlbGV0ZSB2ZXJ3ZW5kZW4hXHJcbiAgICogKGlzRGVsZXRlZCBGbGFnIHN0YXR0IGVjaHRlbSBMw7ZzY2hlbilcclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIFVVSUQgZGVzIFVzZXJzXHJcbiAgICogQHJldHVybnMgdHJ1ZSB3ZW5uIGdlbMO2c2NodCwgZmFsc2Ugd2VubiBuaWNodCBnZWZ1bmRlblxyXG4gICAqL1xyXG4gIGFzeW5jIGRlbGV0ZShpZDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRGVsZXRpbmcgdXNlcjogJHtpZH1gKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGVcclxuICAgICAgLmRlbGV0ZSh1c2VycylcclxuICAgICAgLndoZXJlKGVxKHVzZXJzLmlkLCBpZCkpXHJcbiAgICAgIC5yZXR1cm5pbmcoeyBpZDogdXNlcnMuaWQgfSk7XHJcblxyXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhpcy5sb2dnZXIud2FybihgVXNlciBub3QgZm91bmQgZm9yIGRlbGV0aW9uOiAke2lkfWApO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5sb2dnZXIubG9nKGBVc2VyIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5OiAke2lkfWApO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBaw6RobHQgYWxsZSBVc2VyIChmw7xyIEFkbWluLURhc2hib2FyZClcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIEFuemFobCBkZXIgVXNlclxyXG4gICAqL1xyXG4gIGFzeW5jIGNvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGVcclxuICAgICAgLnNlbGVjdCh7IGNvdW50OiB1c2Vycy5pZCB9KVxyXG4gICAgICAuZnJvbSh1c2Vycyk7XHJcblxyXG4gICAgLy8gRHJpenpsZSBnaWJ0IEFycmF5IHp1csO8Y2ssIHdpciBicmF1Y2hlbiBMw6RuZ2VcclxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoO1xyXG4gIH1cclxufVxyXG4iXSwidmVyc2lvbiI6M30=