{"file":"C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\auth\\strategies\\jwt.strategy.ts","mappings":";AAAA,8CAA8C;;;;;;;;;;;;;;AAE9C,2CAA2E;AAC3E,2CAA+C;AAC/C,+CAAoD;AACpD,+CAAoD;AACpD,uCAA0D;AAG1D;;;;;;;;;;;;;;;;;;;;;GAqBG;AAEI,IAAM,WAAW,mBAAjB,MAAM,WAAY,SAAQ,IAAA,2BAAgB,EAAC,uBAAQ,CAAC;IAItC;IACA;IAJF,MAAM,GAAG,IAAI,eAAM,CAAC,aAAW,CAAC,IAAI,CAAC,CAAC;IAEvD,YACmB,aAA4B,EAC5B,YAA0B;QAE3C,kCAAkC;QAClC,KAAK,CAAC;YACJ,6DAA6D;YAC7D,cAAc,EAAE,yBAAU,CAAC,2BAA2B,EAAE;YAExD,+BAA+B;YAC/B,gBAAgB,EAAE,KAAK;YAEvB,kCAAkC;YAClC,WAAW,EAAE,aAAa,CAAC,GAAG,CAAS,YAAY,CAAC,IAAI,EAAE;YAE1D,mCAAmC;YACnC,UAAU,EAAE,CAAC,OAAO,CAAC;SACtB,CAAC,CAAC;QAhBc,kBAAa,GAAb,aAAa,CAAe;QAC5B,iBAAY,GAAZ,YAAY,CAAc;IAgB7C,CAAC;IAED;;;;;;;;;;OAUG;IACH,KAAK,CAAC,QAAQ,CAAC,OAAmB;QAChC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4BAA4B,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;QAE7D,sCAAsC;QACtC,8EAA8E;QAC9E,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAE3D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,2BAA2B,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;YAC3D,OAAO,IAAI,CAAC;YACZ,6DAA6D;QAC/D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,kCAAkC;YAClC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,+BAA+B,OAAO,CAAC,GAAG,YAAY,CAAC,CAAC;YACzE,MAAM,IAAI,8BAAqB,CAAC,oCAAoC,CAAC,CAAC;QACxE,CAAC;IACH,CAAC;CACF,CAAA;AAnDY,kCAAW;sBAAX,WAAW;IADvB,IAAA,mBAAU,GAAE;yDAKuB,sBAAa,oBAAb,sBAAa,oDACd,oBAAY,oBAAZ,oBAAY;GALlC,WAAW,CAmDvB","names":[],"sources":["C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\auth\\strategies\\jwt.strategy.ts"],"sourcesContent":["// src/modules/auth/strategies/jwt.strategy.ts\r\n\r\nimport { Injectable, Logger, UnauthorizedException } from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport { PassportStrategy } from '@nestjs/passport';\r\nimport { ExtractJwt, Strategy } from 'passport-jwt';\r\nimport { UsersService, type SafeUser } from '../../users';\r\nimport { type JwtPayload } from '../auth.types';\r\n\r\n/**\r\n * JwtStrategy - Validiert JWT Tokens bei geschützten Routes\r\n *\r\n * WIE ES FUNKTIONIERT:\r\n * 1. Request kommt rein mit Authorization:  Bearer <token>\r\n * 2. JwtAuthGuard aktiviert diese Strategy\r\n * 3. passport-jwt extrahiert Token aus Header\r\n * 4. passport-jwt verifiziert Signatur mit Secret\r\n * 5. validate() wird mit decoded Payload aufgerufen\r\n * 6. validate() lädt User aus DB und gibt ihn zurück\r\n * 7. User wird an request.user angehängt\r\n *\r\n * WARUM User aus DB laden statt nur Payload nutzen?\r\n * - User könnte gelöscht/deaktiviert worden sein\r\n * - User-Rolle könnte sich geändert haben\r\n * - Wir brauchen aktuelle User-Daten\r\n *\r\n * ALTERNATIVE:  Nur Payload nutzen (ohne DB-Query)\r\n * Pro: Schneller (kein DB-Roundtrip)\r\n * Contra: Veraltete Daten möglich\r\n * Entscheidung: DB-Query für Sicherheit (bei jedem Request)\r\n */\r\n@Injectable()\r\nexport class JwtStrategy extends PassportStrategy(Strategy) {\r\n  private readonly logger = new Logger(JwtStrategy.name);\r\n\r\n  constructor(\r\n    private readonly configService: ConfigService,\r\n    private readonly usersService: UsersService,\r\n  ) {\r\n    // Passport Strategy Konfiguration\r\n    super({\r\n      // Wo ist der Token?  → Authorization Header als Bearer Token\r\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\r\n\r\n      // Abgelaufene Tokens ablehnen?\r\n      ignoreExpiration: false,\r\n\r\n      // Secret für Signatur-Validierung\r\n      secretOrKey: configService.get<string>('JWT_SECRET') || '',\r\n\r\n      // Algorithms die akzeptiert werden\r\n      algorithms: ['HS256'],\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate - Wird nach erfolgreicher Token-Verifikation aufgerufen\r\n   *\r\n   * WICHTIG: Wenn diese Methode einen Wert zurückgibt,\r\n   * wird dieser an request.user angehängt.\r\n   * Wenn sie eine Exception wirft, wird 401 zurückgegeben.\r\n   *\r\n   * @param payload - Decoded JWT Payload (bereits verifiziert!)\r\n   * @returns SafeUser für request.user\r\n   * @throws UnauthorizedException wenn User nicht existiert\r\n   */\r\n  async validate(payload: JwtPayload): Promise<SafeUser> {\r\n    this.logger.debug(`Validating JWT for user: ${payload.sub}`);\r\n\r\n    // User aus DB laden (aktuelle Daten!)\r\n    // Wir nutzen try-catch weil findById eine Exception wirft wenn nicht gefunden\r\n    try {\r\n      const user = await this.usersService.findById(payload.sub);\r\n\r\n      this.logger.debug(`JWT validated for user: ${user.email}`);\r\n      return user;\r\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    } catch (error) {\r\n      // User nicht gefunden (gelöscht?)\r\n      this.logger.warn(`JWT validation failed: User ${payload.sub} not found`);\r\n      throw new UnauthorizedException('User not found or has been deleted');\r\n    }\r\n  }\r\n}\r\n"],"version":3}