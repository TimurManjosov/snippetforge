{"file":"C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\auth\\auth.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\auth\\auth.service.ts"],"sourcesContent":["// src/modules/auth/auth.service.ts\r\n\r\nimport { Injectable, Logger, UnauthorizedException } from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { UsersService, type SafeUser } from '../users';\r\nimport {\r\n  type AuthResponse,\r\n  type JwtPayload,\r\n  type TokenResponse,\r\n} from './auth.types';\r\nimport { type LoginDto } from './dto/login.dto';\r\nimport { type RegisterDto } from './dto/register.dto';\r\n\r\n/**\r\n * AuthService - Zentrale Authentifizierungs-Logik\r\n *\r\n * VERANTWORTLICHKEITEN:\r\n * - User Registration (delegiert an UsersService)\r\n * - User Login (Credential-Validierung + Token-Generierung)\r\n * - Token-Generierung (JWT)\r\n *\r\n * WAS HIER NICHT PASSIERT:\r\n * - Password Hashing (→ UsersService)\r\n * - User CRUD (→ UsersService)\r\n * - Token-Validierung (→ JwtStrategy)\r\n * - HTTP Concerns (→ AuthController)\r\n *\r\n * SECURITY CONSIDERATIONS:\r\n * - Keine User Enumeration bei Login\r\n * - Timing-Safe Password Comparison (in UsersService)\r\n * - Minimaler JWT Payload\r\n */\r\n@Injectable()\r\nexport class AuthService {\r\n  private readonly logger = new Logger(AuthService.name);\r\n\r\n  // Token Expiration in Sekunden (aus Config oder Default 15 Minuten)\r\n  private readonly accessTokenExpiresIn: number;\r\n\r\n  constructor(\r\n    private readonly usersService: UsersService,\r\n    private readonly jwtService: JwtService,\r\n    private readonly configService: ConfigService,\r\n  ) {\r\n    // Parse JWT_EXPIRES_IN (z.B. \"15m\", \"1h\", \"7d\")\r\n    const expiresInString =\r\n      this.configService.get<string>('JWT_EXPIRES_IN') || '15m';\r\n    this.accessTokenExpiresIn = this.parseExpiresIn(expiresInString);\r\n  }\r\n\r\n  // ============================================================\r\n  // PUBLIC METHODS\r\n  // ============================================================\r\n\r\n  /**\r\n   * Register - Erstellt neuen User und gibt Tokens zurück\r\n   *\r\n   * @param dto - RegisterDto (email, username, password)\r\n   * @returns AuthResponse (user + tokens)\r\n   * @throws ConflictException wenn Email/Username existiert (von UsersService)\r\n   */\r\n  async register(dto: RegisterDto): Promise<AuthResponse> {\r\n    this.logger.debug(`Registering new user: ${dto.email}`);\r\n\r\n    // 1. User erstellen (UsersService handled Hashing + Duplicate Check)\r\n    const user = await this.usersService.create({\r\n      email: dto.email,\r\n      username: dto.username,\r\n      password: dto.password,\r\n    });\r\n\r\n    // 2. Tokens generieren\r\n    const tokens = await this.generateTokens(user);\r\n\r\n    this.logger.log(`User registered successfully: ${user.id}`);\r\n\r\n    return {\r\n      user,\r\n      tokens,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Login - Validiert Credentials und gibt Tokens zurück\r\n   *\r\n   * SECURITY:\r\n   * - Gleiche Fehlermeldung bei \"Email nicht gefunden\" und \"Passwort falsch\"\r\n   * - Verhindert User Enumeration\r\n   *\r\n   * @param dto - LoginDto (email, password)\r\n   * @returns AuthResponse (user + tokens)\r\n   * @throws UnauthorizedException bei ungültigen Credentials\r\n   */\r\n  async login(dto: LoginDto): Promise<AuthResponse> {\r\n    this.logger.debug(`Login attempt for: ${dto.email}`);\r\n\r\n    // 1. Credentials validieren (UsersService macht Timing-Safe Comparison)\r\n    const user = await this.usersService.validateCredentials(\r\n      dto.email,\r\n      dto.password,\r\n    );\r\n\r\n    // 2. Wenn null → Credentials ungültig\r\n    if (!user) {\r\n      this.logger.warn(`Failed login attempt for: ${dto.email}`);\r\n      // SECURITY: Gleiche Message für alle Fehler!\r\n      throw new UnauthorizedException('Invalid email or password');\r\n    }\r\n\r\n    // 3. Tokens generieren\r\n    const tokens = await this.generateTokens(user);\r\n\r\n    this.logger.log(`User logged in successfully: ${user.id}`);\r\n\r\n    return {\r\n      user,\r\n      tokens,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * ValidateUserById - Lädt User für Token-Refresh\r\n   *\r\n   * @param userId - UUID des Users\r\n   * @returns SafeUser\r\n   * @throws NotFoundException wenn User nicht existiert\r\n   */\r\n  async validateUserById(userId: string): Promise<SafeUser> {\r\n    return this.usersService.findById(userId);\r\n  }\r\n\r\n  /**\r\n   * GetCurrentUser - Alias für findById (für Controller-Klarheit)\r\n   */\r\n  async getCurrentUser(userId: string): Promise<SafeUser> {\r\n    return this.usersService.findById(userId);\r\n  }\r\n\r\n  // ============================================================\r\n  // PRIVATE METHODS\r\n  // ============================================================\r\n\r\n  /**\r\n   * Generiert JWT Access Token\r\n   *\r\n   * @param user - SafeUser für Payload\r\n   * @returns TokenResponse\r\n   */\r\n  private async generateTokens(user: SafeUser): Promise<TokenResponse> {\r\n    // JWT Payload (minimale Daten!)\r\n    const payload: JwtPayload = {\r\n      sub: user.id, // Standard JWT Claim für Subject (User ID)\r\n      email: user.email, // Für schnellen Lookup\r\n      role: user.role, // Für Authorization ohne DB-Query\r\n    };\r\n\r\n    // Token signieren\r\n    const accessToken = await this.jwtService.signAsync(payload);\r\n\r\n    return {\r\n      accessToken,\r\n      tokenType: 'Bearer',\r\n      expiresIn: this.accessTokenExpiresIn,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Parsed JWT_EXPIRES_IN String zu Sekunden\r\n   *\r\n   * Unterstützte Formate:\r\n   * - \"15m\" → 900 (15 Minuten)\r\n   * - \"1h\" → 3600 (1 Stunde)\r\n   * - \"7d\" → 604800 (7 Tage)\r\n   * - \"3600\" → 3600 (direkt Sekunden)\r\n   */\r\n  private parseExpiresIn(value: string): number {\r\n    const match = value.match(/^(\\d+)(s|m|h|d)?$/);\r\n\r\n    if (!match) {\r\n      this.logger.warn(\r\n        `Invalid JWT_EXPIRES_IN format: ${value}, using default 15m`,\r\n      );\r\n      return 900; // Default:  15 Minuten\r\n    }\r\n\r\n    const num = parseInt(match[1], 10);\r\n    const unit = match[2] || 's';\r\n\r\n    switch (unit) {\r\n      case 's':\r\n        return num;\r\n      case 'm':\r\n        return num * 60;\r\n      case 'h':\r\n        return num * 60 * 60;\r\n      case 'd':\r\n        return num * 60 * 60 * 24;\r\n      default:\r\n        return num;\r\n    }\r\n  }\r\n}\r\n"],"version":3}