29c92a36e7c3782438ccdfd39814c517
"use strict";
// test/setup/test-utils.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTestingModule = createTestingModule;
exports.createTestingApp = createTestingApp;
exports.delay = delay;
exports.randomEmail = randomEmail;
exports.randomUsername = randomUsername;
exports.createMockRequest = createMockRequest;
exports.createMockResponse = createMockResponse;
exports.createMockExecutionContext = createMockExecutionContext;
exports.createMockArgumentsHost = createMockArgumentsHost;
const testing_1 = require("@nestjs/testing");
const filters_1 = require("../../src/shared/filters");
/**
 * Test Utilities
 *
 * Wiederverwendbare Funktionen für Tests.
 * Reduziert Boilerplate und sorgt für Konsistenz.
 */
/**
 * Erstellt ein NestJS Testing Module mit Standard-Konfiguration
 *
 * @param metadata - Module Metadata (providers, imports, etc.)
 * @returns Kompiliertes Test-Module
 */
async function createTestingModule(metadata) {
    return testing_1.Test.createTestingModule(metadata).compile();
}
/**
 * Erstellt eine vollständige NestJS Test-Application
 * Verwendet für E2E Tests
 *
 * @param moduleType - Das zu testende Module
 * @returns Initialisierte Nest Application
 */
async function createTestingApp(moduleType) {
    const moduleFixture = await testing_1.Test.createTestingModule({
        imports: [moduleType],
    }).compile();
    const app = moduleFixture.createNestApplication();
    // Gleiche Konfiguration wie Production
    app.setGlobalPrefix('api');
    app.useGlobalFilters(new filters_1.AllExceptionsFilter(), new filters_1.HttpExceptionFilter());
    await app.init();
    return app;
}
/**
 * Wartet eine bestimmte Zeit (für async Tests)
 */
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Generiert eine zufällige Email für Tests
 * Verhindert Konflikte bei parallelen Tests
 */
function randomEmail() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    return `test-${timestamp}-${random}@test.com`;
}
/**
 * Generiert einen zufälligen Username für Tests
 */
function randomUsername() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    return `user_${timestamp}_${random}`.substring(0, 30);
}
/**
 * Mock Request Object für Filter/Guard Tests
 */
function createMockRequest(overrides = {}) {
    return {
        url: '/api/test',
        method: 'GET',
        headers: {},
        user: undefined,
        ...overrides,
    };
}
/**
 * Mock Response Object für Filter Tests
 */
function createMockResponse() {
    const response = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn().mockReturnThis(),
        send: jest.fn().mockReturnThis(),
    };
    return response;
}
/**
 * Mock Execution Context für Guards
 */
function createMockExecutionContext(overrides = {}) {
    const mockRequest = {
        user: undefined,
        headers: {},
        ...overrides.request,
    };
    return {
        switchToHttp: () => ({
            getRequest: () => mockRequest,
            getResponse: () => createMockResponse(),
        }),
        getHandler: () => overrides.handler || jest.fn(),
        getClass: () => overrides.class || class TestController {
        },
    };
}
/**
 * Mock ArgumentsHost für Filters
 */
function createMockArgumentsHost(request = createMockRequest(), response = createMockResponse()) {
    return {
        switchToHttp: () => ({
            getRequest: () => request,
            getResponse: () => response,
        }),
        getArgs: () => [],
        getArgByIndex: () => undefined,
        switchToRpc: () => ({ getData: () => undefined }),
        switchToWs: () => ({ getData: () => undefined }),
        getType: () => 'http',
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aW11clxcUHJvZ3JhbW1pbmdcXFByb2plY3RzXFxzbmlwcGV0Zm9yZ2VcXGFwcHNcXGFwaVxcdGVzdFxcc2V0dXBcXHRlc3QtdXRpbHMudHMiLCJtYXBwaW5ncyI6IjtBQUFBLDJCQUEyQjs7QUFzQjNCLGtEQUlDO0FBU0QsNENBZUM7QUFLRCxzQkFFQztBQU1ELGtDQUlDO0FBS0Qsd0NBSUM7QUFLRCw4Q0FlQztBQUtELGdEQU9DO0FBS0QsZ0VBcUJDO0FBS0QsMERBZUM7QUF2SkQsNkNBQXNEO0FBQ3RELHNEQUdrQztBQUVsQzs7Ozs7R0FLRztBQUVIOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLG1CQUFtQixDQUN2QyxRQUF3QjtJQUV4QixPQUFPLGNBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUN0RCxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0ksS0FBSyxVQUFVLGdCQUFnQixDQUNwQyxVQUF5QjtJQUV6QixNQUFNLGFBQWEsR0FBRyxNQUFNLGNBQUksQ0FBQyxtQkFBbUIsQ0FBQztRQUNuRCxPQUFPLEVBQUUsQ0FBQyxVQUFVLENBQUM7S0FDdEIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBRWIsTUFBTSxHQUFHLEdBQUcsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUM7SUFFbEQsdUNBQXVDO0lBQ3ZDLEdBQUcsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksNkJBQW1CLEVBQUUsRUFBRSxJQUFJLDZCQUFtQixFQUFFLENBQUMsQ0FBQztJQUUzRSxNQUFNLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNqQixPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLEtBQUssQ0FBQyxFQUFVO0lBQzlCLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUMzRCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBZ0IsV0FBVztJQUN6QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFELE9BQU8sUUFBUSxTQUFTLElBQUksTUFBTSxXQUFXLENBQUM7QUFDaEQsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsY0FBYztJQUM1QixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFELE9BQU8sUUFBUSxTQUFTLElBQUksTUFBTSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixpQkFBaUIsQ0FDL0IsWUFLSyxFQUFFO0lBRVAsT0FBTztRQUNMLEdBQUcsRUFBRSxXQUFXO1FBQ2hCLE1BQU0sRUFBRSxLQUFLO1FBQ2IsT0FBTyxFQUFFLEVBQUU7UUFDWCxJQUFJLEVBQUUsU0FBUztRQUNmLEdBQUcsU0FBUztLQUNiLENBQUM7QUFDSixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixrQkFBa0I7SUFDaEMsTUFBTSxRQUFRLEdBQUc7UUFDZixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRTtRQUNsQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRTtRQUNoQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGNBQWMsRUFBRTtLQUNqQyxDQUFDO0lBQ0YsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsMEJBQTBCLENBQ3hDLFlBSUksRUFBRTtJQUVOLE1BQU0sV0FBVyxHQUFHO1FBQ2xCLElBQUksRUFBRSxTQUFTO1FBQ2YsT0FBTyxFQUFFLEVBQUU7UUFDWCxHQUFHLFNBQVMsQ0FBQyxPQUFPO0tBQ3JCLENBQUM7SUFFRixPQUFPO1FBQ0wsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDbkIsVUFBVSxFQUFFLEdBQUcsRUFBRSxDQUFDLFdBQVc7WUFDN0IsV0FBVyxFQUFFLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixFQUFFO1NBQ3hDLENBQUM7UUFDRixVQUFVLEVBQUUsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2hELFFBQVEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxJQUFJLE1BQU0sY0FBYztTQUFHO0tBQzNELENBQUM7QUFDSixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQix1QkFBdUIsQ0FDckMsT0FBTyxHQUFHLGlCQUFpQixFQUFFLEVBQzdCLFFBQVEsR0FBRyxrQkFBa0IsRUFBRTtJQUUvQixPQUFPO1FBQ0wsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDbkIsVUFBVSxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU87WUFDekIsV0FBVyxFQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVE7U0FDNUIsQ0FBQztRQUNGLE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFO1FBQ2pCLGFBQWEsRUFBRSxHQUFHLEVBQUUsQ0FBQyxTQUFTO1FBQzlCLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2pELFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2hELE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQyxNQUFlO0tBQy9CLENBQUM7QUFDSixDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdGltdXJcXFByb2dyYW1taW5nXFxQcm9qZWN0c1xcc25pcHBldGZvcmdlXFxhcHBzXFxhcGlcXHRlc3RcXHNldHVwXFx0ZXN0LXV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRlc3Qvc2V0dXAvdGVzdC11dGlscy50c1xyXG5cclxuaW1wb3J0IHsgSU5lc3RBcHBsaWNhdGlvbiwgTW9kdWxlTWV0YWRhdGEsIFR5cGUgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XHJcbmltcG9ydCB7IFRlc3QsIFRlc3RpbmdNb2R1bGUgfSBmcm9tICdAbmVzdGpzL3Rlc3RpbmcnO1xyXG5pbXBvcnQge1xyXG4gIEFsbEV4Y2VwdGlvbnNGaWx0ZXIsXHJcbiAgSHR0cEV4Y2VwdGlvbkZpbHRlcixcclxufSBmcm9tICcuLi8uLi9zcmMvc2hhcmVkL2ZpbHRlcnMnO1xyXG5cclxuLyoqXHJcbiAqIFRlc3QgVXRpbGl0aWVzXHJcbiAqXHJcbiAqIFdpZWRlcnZlcndlbmRiYXJlIEZ1bmt0aW9uZW4gZsO8ciBUZXN0cy5cclxuICogUmVkdXppZXJ0IEJvaWxlcnBsYXRlIHVuZCBzb3JndCBmw7xyIEtvbnNpc3RlbnouXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEVyc3RlbGx0IGVpbiBOZXN0SlMgVGVzdGluZyBNb2R1bGUgbWl0IFN0YW5kYXJkLUtvbmZpZ3VyYXRpb25cclxuICpcclxuICogQHBhcmFtIG1ldGFkYXRhIC0gTW9kdWxlIE1ldGFkYXRhIChwcm92aWRlcnMsIGltcG9ydHMsIGV0Yy4pXHJcbiAqIEByZXR1cm5zIEtvbXBpbGllcnRlcyBUZXN0LU1vZHVsZVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRlc3RpbmdNb2R1bGUoXHJcbiAgbWV0YWRhdGE6IE1vZHVsZU1ldGFkYXRhLFxyXG4pOiBQcm9taXNlPFRlc3RpbmdNb2R1bGU+IHtcclxuICByZXR1cm4gVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKG1ldGFkYXRhKS5jb21waWxlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFcnN0ZWxsdCBlaW5lIHZvbGxzdMOkbmRpZ2UgTmVzdEpTIFRlc3QtQXBwbGljYXRpb25cclxuICogVmVyd2VuZGV0IGbDvHIgRTJFIFRlc3RzXHJcbiAqXHJcbiAqIEBwYXJhbSBtb2R1bGVUeXBlIC0gRGFzIHp1IHRlc3RlbmRlIE1vZHVsZVxyXG4gKiBAcmV0dXJucyBJbml0aWFsaXNpZXJ0ZSBOZXN0IEFwcGxpY2F0aW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGVzdGluZ0FwcChcclxuICBtb2R1bGVUeXBlOiBUeXBlPHVua25vd24+LFxyXG4pOiBQcm9taXNlPElOZXN0QXBwbGljYXRpb24+IHtcclxuICBjb25zdCBtb2R1bGVGaXh0dXJlID0gYXdhaXQgVGVzdC5jcmVhdGVUZXN0aW5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFttb2R1bGVUeXBlXSxcclxuICB9KS5jb21waWxlKCk7XHJcblxyXG4gIGNvbnN0IGFwcCA9IG1vZHVsZUZpeHR1cmUuY3JlYXRlTmVzdEFwcGxpY2F0aW9uKCk7XHJcblxyXG4gIC8vIEdsZWljaGUgS29uZmlndXJhdGlvbiB3aWUgUHJvZHVjdGlvblxyXG4gIGFwcC5zZXRHbG9iYWxQcmVmaXgoJ2FwaScpO1xyXG4gIGFwcC51c2VHbG9iYWxGaWx0ZXJzKG5ldyBBbGxFeGNlcHRpb25zRmlsdGVyKCksIG5ldyBIdHRwRXhjZXB0aW9uRmlsdGVyKCkpO1xyXG5cclxuICBhd2FpdCBhcHAuaW5pdCgpO1xyXG4gIHJldHVybiBhcHA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXYXJ0ZXQgZWluZSBiZXN0aW1tdGUgWmVpdCAoZsO8ciBhc3luYyBUZXN0cylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWxheShtczogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmllcnQgZWluZSB6dWbDpGxsaWdlIEVtYWlsIGbDvHIgVGVzdHNcclxuICogVmVyaGluZGVydCBLb25mbGlrdGUgYmVpIHBhcmFsbGVsZW4gVGVzdHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByYW5kb21FbWFpbCgpOiBzdHJpbmcge1xyXG4gIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgY29uc3QgcmFuZG9tID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDgpO1xyXG4gIHJldHVybiBgdGVzdC0ke3RpbWVzdGFtcH0tJHtyYW5kb219QHRlc3QuY29tYDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyaWVydCBlaW5lbiB6dWbDpGxsaWdlbiBVc2VybmFtZSBmw7xyIFRlc3RzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tVXNlcm5hbWUoKTogc3RyaW5nIHtcclxuICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KTtcclxuICByZXR1cm4gYHVzZXJfJHt0aW1lc3RhbXB9XyR7cmFuZG9tfWAuc3Vic3RyaW5nKDAsIDMwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1vY2sgUmVxdWVzdCBPYmplY3QgZsO8ciBGaWx0ZXIvR3VhcmQgVGVzdHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNb2NrUmVxdWVzdChcclxuICBvdmVycmlkZXM6IFBhcnRpYWw8e1xyXG4gICAgdXJsOiBzdHJpbmc7XHJcbiAgICBtZXRob2Q6IHN0cmluZztcclxuICAgIGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XHJcbiAgICB1c2VyOiB1bmtub3duO1xyXG4gIH0+ID0ge30sXHJcbikge1xyXG4gIHJldHVybiB7XHJcbiAgICB1cmw6ICcvYXBpL3Rlc3QnLFxyXG4gICAgbWV0aG9kOiAnR0VUJyxcclxuICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgdXNlcjogdW5kZWZpbmVkLFxyXG4gICAgLi4ub3ZlcnJpZGVzLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNb2NrIFJlc3BvbnNlIE9iamVjdCBmw7xyIEZpbHRlciBUZXN0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tSZXNwb25zZSgpIHtcclxuICBjb25zdCByZXNwb25zZSA9IHtcclxuICAgIHN0YXR1czogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXHJcbiAgICBqc29uOiBqZXN0LmZuKCkubW9ja1JldHVyblRoaXMoKSxcclxuICAgIHNlbmQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVGhpcygpLFxyXG4gIH07XHJcbiAgcmV0dXJuIHJlc3BvbnNlO1xyXG59XHJcblxyXG4vKipcclxuICogTW9jayBFeGVjdXRpb24gQ29udGV4dCBmw7xyIEd1YXJkc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tFeGVjdXRpb25Db250ZXh0KFxyXG4gIG92ZXJyaWRlczoge1xyXG4gICAgcmVxdWVzdD86IFBhcnRpYWw8eyB1c2VyOiB1bmtub3duOyBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IH0+O1xyXG4gICAgaGFuZGxlcj86IHVua25vd247XHJcbiAgICBjbGFzcz86IHVua25vd247XHJcbiAgfSA9IHt9LFxyXG4pIHtcclxuICBjb25zdCBtb2NrUmVxdWVzdCA9IHtcclxuICAgIHVzZXI6IHVuZGVmaW5lZCxcclxuICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgLi4ub3ZlcnJpZGVzLnJlcXVlc3QsXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN3aXRjaFRvSHR0cDogKCkgPT4gKHtcclxuICAgICAgZ2V0UmVxdWVzdDogKCkgPT4gbW9ja1JlcXVlc3QsXHJcbiAgICAgIGdldFJlc3BvbnNlOiAoKSA9PiBjcmVhdGVNb2NrUmVzcG9uc2UoKSxcclxuICAgIH0pLFxyXG4gICAgZ2V0SGFuZGxlcjogKCkgPT4gb3ZlcnJpZGVzLmhhbmRsZXIgfHwgamVzdC5mbigpLFxyXG4gICAgZ2V0Q2xhc3M6ICgpID0+IG92ZXJyaWRlcy5jbGFzcyB8fCBjbGFzcyBUZXN0Q29udHJvbGxlciB7fSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogTW9jayBBcmd1bWVudHNIb3N0IGbDvHIgRmlsdGVyc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tBcmd1bWVudHNIb3N0KFxyXG4gIHJlcXVlc3QgPSBjcmVhdGVNb2NrUmVxdWVzdCgpLFxyXG4gIHJlc3BvbnNlID0gY3JlYXRlTW9ja1Jlc3BvbnNlKCksXHJcbikge1xyXG4gIHJldHVybiB7XHJcbiAgICBzd2l0Y2hUb0h0dHA6ICgpID0+ICh7XHJcbiAgICAgIGdldFJlcXVlc3Q6ICgpID0+IHJlcXVlc3QsXHJcbiAgICAgIGdldFJlc3BvbnNlOiAoKSA9PiByZXNwb25zZSxcclxuICAgIH0pLFxyXG4gICAgZ2V0QXJnczogKCkgPT4gW10sXHJcbiAgICBnZXRBcmdCeUluZGV4OiAoKSA9PiB1bmRlZmluZWQsXHJcbiAgICBzd2l0Y2hUb1JwYzogKCkgPT4gKHsgZ2V0RGF0YTogKCkgPT4gdW5kZWZpbmVkIH0pLFxyXG4gICAgc3dpdGNoVG9XczogKCkgPT4gKHsgZ2V0RGF0YTogKCkgPT4gdW5kZWZpbmVkIH0pLFxyXG4gICAgZ2V0VHlwZTogKCkgPT4gJ2h0dHAnIGFzIGNvbnN0LFxyXG4gIH07XHJcbn1cclxuIl0sInZlcnNpb24iOjN9