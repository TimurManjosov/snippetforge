fa0f403e31becfb6c3e0f682d79ae76c
"use strict";
// src/modules/auth/guards/jwt-auth.guard.ts
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var JwtAuthGuard_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwtAuthGuard = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const passport_1 = require("@nestjs/passport");
const public_decorator_1 = require("../decorators/public.decorator");
/**
 * JwtAuthGuard - Schützt Routes vor unauthentifizierten Zugriffen
 *
 * WIE ES FUNKTIONIERT:
 * 1. Guard wird auf Route/Controller angewendet
 * 2. canActivate() wird aufgerufen
 * 3. Prüft ob Route @Public() ist → Wenn ja, erlauben
 * 4. Wenn nicht public, delegiert an Passport JwtStrategy
 * 5. JwtStrategy validiert Token und lädt User
 * 6. Wenn erfolgreich:  request.user = User, Route wird ausgeführt
 * 7. Wenn fehlgeschlagen: 401 Unauthorized
 *
 * VERWENDUNG:
 *
 * // Auf einzelner Route
 * @UseGuards(JwtAuthGuard)
 * @Get('profile')
 * getProfile() {}
 *
 * // Global auf allen Routes (in main.ts)
 * app.useGlobalGuards(new JwtAuthGuard(reflector))
 *
 * // Route von Auth ausnehmen
 * @Public()
 * @Get('health')
 * healthCheck() {}
 */
let JwtAuthGuard = JwtAuthGuard_1 = class JwtAuthGuard extends (0, passport_1.AuthGuard)('jwt') {
    reflector;
    logger = new common_1.Logger(JwtAuthGuard_1.name);
    constructor(reflector) {
        super();
        this.reflector = reflector;
    }
    /**
     * canActivate - Entscheidet ob Request durchgelassen wird
     *
     * @param context - Execution Context (enthält Request, Handler, etc.)
     * @returns true wenn erlaubt, false/Exception wenn nicht
     */
    canActivate(context) {
        // 1. Prüfe ob Route als @Public() markiert ist
        const isPublic = this.reflector.getAllAndOverride(public_decorator_1.IS_PUBLIC_KEY, [
            context.getHandler(), // Methode (@Public() auf Methode)
            context.getClass(), // Controller (@Public() auf Controller)
        ]);
        // 2. Wenn public, sofort erlauben (keine Token-Prüfung)
        if (isPublic) {
            this.logger.debug('Public route accessed, skipping authentication');
            return true;
        }
        // 3. Wenn nicht public, Passport JWT Strategy ausführen
        return super.canActivate(context);
    }
    /**
     * handleRequest - Verarbeitet Passport-Ergebnis
     *
     * Wird nach JwtStrategy.validate() aufgerufen
     * Erlaubt uns, den Error/User zu customizen
     *
     * @param err - Error von Passport (null wenn erfolgreich)
     * @param user - User von JwtStrategy. validate() (undefined wenn fehlgeschlagen)
     * @param info - Zusätzliche Info (z.B. "jwt expired")
     * @returns User wenn erfolgreich
     * @throws UnauthorizedException wenn fehlgeschlagen
     */
    handleRequest(err, user, info) {
        // Passport Error (z.B. invalid signature)
        if (err) {
            this.logger.warn(`Authentication error: ${err.message}`);
            throw new common_1.UnauthorizedException('Authentication failed');
        }
        // Kein User (Token invalid/expired oder User nicht gefunden)
        if (!user) {
            const message = info?.message || 'Invalid or missing authentication token';
            this.logger.warn(`Authentication failed: ${message}`);
            throw new common_1.UnauthorizedException(message);
        }
        return user;
    }
};
exports.JwtAuthGuard = JwtAuthGuard;
exports.JwtAuthGuard = JwtAuthGuard = JwtAuthGuard_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof core_1.Reflector !== "undefined" && core_1.Reflector) === "function" ? _a : Object])
], JwtAuthGuard);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFx0aW11clxcUHJvZ3JhbW1pbmdcXFByb2plY3RzXFxzbmlwcGV0Zm9yZ2VcXGFwcHNcXGFwaVxcc3JjXFxtb2R1bGVzXFxhdXRoXFxndWFyZHNcXGp3dC1hdXRoLmd1YXJkLnRzIiwibWFwcGluZ3MiOiI7QUFBQSw0Q0FBNEM7Ozs7Ozs7Ozs7Ozs7O0FBRTVDLDJDQUt3QjtBQUN4Qix1Q0FBeUM7QUFDekMsK0NBQTZDO0FBQzdDLHFFQUErRDtBQUUvRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwQkc7QUFFSSxJQUFNLFlBQVksb0JBQWxCLE1BQU0sWUFBYSxTQUFRLElBQUEsb0JBQVMsRUFBQyxLQUFLLENBQUM7SUFHNUI7SUFGSCxNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsY0FBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXhELFlBQW9CLFNBQW9CO1FBQ3RDLEtBQUssRUFBRSxDQUFDO1FBRFUsY0FBUyxHQUFULFNBQVMsQ0FBVztJQUV4QyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxXQUFXLENBQUMsT0FBeUI7UUFDbkMsK0NBQStDO1FBQy9DLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQVUsZ0NBQWEsRUFBRTtZQUN4RSxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsa0NBQWtDO1lBQ3hELE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSx3Q0FBd0M7U0FDN0QsQ0FBQyxDQUFDO1FBRUgsd0RBQXdEO1FBQ3hELElBQUksUUFBUSxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO1lBQ3BFLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELHdEQUF3RDtRQUN4RCxPQUFPLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0gsYUFBYSxDQUFJLEdBQWlCLEVBQUUsSUFBTyxFQUFFLElBQXVCO1FBQ2xFLDBDQUEwQztRQUMxQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1lBQ1IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMseUJBQXlCLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1lBQ3pELE1BQU0sSUFBSSw4QkFBcUIsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQzNELENBQUM7UUFFRCw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ1YsTUFBTSxPQUFPLEdBQ1gsSUFBSSxFQUFFLE9BQU8sSUFBSSx5Q0FBeUMsQ0FBQztZQUM3RCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQywwQkFBMEIsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUN0RCxNQUFNLElBQUksOEJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0MsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGLENBQUE7QUEzRFksb0NBQVk7dUJBQVosWUFBWTtJQUR4QixJQUFBLG1CQUFVLEdBQUU7eURBSW9CLGdCQUFTLG9CQUFULGdCQUFTO0dBSDdCLFlBQVksQ0EyRHhCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcdGltdXJcXFByb2dyYW1taW5nXFxQcm9qZWN0c1xcc25pcHBldGZvcmdlXFxhcHBzXFxhcGlcXHNyY1xcbW9kdWxlc1xcYXV0aFxcZ3VhcmRzXFxqd3QtYXV0aC5ndWFyZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbW9kdWxlcy9hdXRoL2d1YXJkcy9qd3QtYXV0aC5ndWFyZC50c1xyXG5cclxuaW1wb3J0IHtcclxuICBFeGVjdXRpb25Db250ZXh0LFxyXG4gIEluamVjdGFibGUsXHJcbiAgTG9nZ2VyLFxyXG4gIFVuYXV0aG9yaXplZEV4Y2VwdGlvbixcclxufSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XHJcbmltcG9ydCB7IFJlZmxlY3RvciB9IGZyb20gJ0BuZXN0anMvY29yZSc7XHJcbmltcG9ydCB7IEF1dGhHdWFyZCB9IGZyb20gJ0BuZXN0anMvcGFzc3BvcnQnO1xyXG5pbXBvcnQgeyBJU19QVUJMSUNfS0VZIH0gZnJvbSAnLi4vZGVjb3JhdG9ycy9wdWJsaWMuZGVjb3JhdG9yJztcclxuXHJcbi8qKlxyXG4gKiBKd3RBdXRoR3VhcmQgLSBTY2jDvHR6dCBSb3V0ZXMgdm9yIHVuYXV0aGVudGlmaXppZXJ0ZW4gWnVncmlmZmVuXHJcbiAqXHJcbiAqIFdJRSBFUyBGVU5LVElPTklFUlQ6XHJcbiAqIDEuIEd1YXJkIHdpcmQgYXVmIFJvdXRlL0NvbnRyb2xsZXIgYW5nZXdlbmRldFxyXG4gKiAyLiBjYW5BY3RpdmF0ZSgpIHdpcmQgYXVmZ2VydWZlblxyXG4gKiAzLiBQcsO8ZnQgb2IgUm91dGUgQFB1YmxpYygpIGlzdCDihpIgV2VubiBqYSwgZXJsYXViZW5cclxuICogNC4gV2VubiBuaWNodCBwdWJsaWMsIGRlbGVnaWVydCBhbiBQYXNzcG9ydCBKd3RTdHJhdGVneVxyXG4gKiA1LiBKd3RTdHJhdGVneSB2YWxpZGllcnQgVG9rZW4gdW5kIGzDpGR0IFVzZXJcclxuICogNi4gV2VubiBlcmZvbGdyZWljaDogIHJlcXVlc3QudXNlciA9IFVzZXIsIFJvdXRlIHdpcmQgYXVzZ2Vmw7xocnRcclxuICogNy4gV2VubiBmZWhsZ2VzY2hsYWdlbjogNDAxIFVuYXV0aG9yaXplZFxyXG4gKlxyXG4gKiBWRVJXRU5EVU5HOlxyXG4gKlxyXG4gKiAvLyBBdWYgZWluemVsbmVyIFJvdXRlXHJcbiAqIEBVc2VHdWFyZHMoSnd0QXV0aEd1YXJkKVxyXG4gKiBAR2V0KCdwcm9maWxlJylcclxuICogZ2V0UHJvZmlsZSgpIHt9XHJcbiAqXHJcbiAqIC8vIEdsb2JhbCBhdWYgYWxsZW4gUm91dGVzIChpbiBtYWluLnRzKVxyXG4gKiBhcHAudXNlR2xvYmFsR3VhcmRzKG5ldyBKd3RBdXRoR3VhcmQocmVmbGVjdG9yKSlcclxuICpcclxuICogLy8gUm91dGUgdm9uIEF1dGggYXVzbmVobWVuXHJcbiAqIEBQdWJsaWMoKVxyXG4gKiBAR2V0KCdoZWFsdGgnKVxyXG4gKiBoZWFsdGhDaGVjaygpIHt9XHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBKd3RBdXRoR3VhcmQgZXh0ZW5kcyBBdXRoR3VhcmQoJ2p3dCcpIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoSnd0QXV0aEd1YXJkLm5hbWUpO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZmxlY3RvcjogUmVmbGVjdG9yKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogY2FuQWN0aXZhdGUgLSBFbnRzY2hlaWRldCBvYiBSZXF1ZXN0IGR1cmNoZ2VsYXNzZW4gd2lyZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNvbnRleHQgLSBFeGVjdXRpb24gQ29udGV4dCAoZW50aMOkbHQgUmVxdWVzdCwgSGFuZGxlciwgZXRjLilcclxuICAgKiBAcmV0dXJucyB0cnVlIHdlbm4gZXJsYXVidCwgZmFsc2UvRXhjZXB0aW9uIHdlbm4gbmljaHRcclxuICAgKi9cclxuICBjYW5BY3RpdmF0ZShjb250ZXh0OiBFeGVjdXRpb25Db250ZXh0KSB7XHJcbiAgICAvLyAxLiBQcsO8ZmUgb2IgUm91dGUgYWxzIEBQdWJsaWMoKSBtYXJraWVydCBpc3RcclxuICAgIGNvbnN0IGlzUHVibGljID0gdGhpcy5yZWZsZWN0b3IuZ2V0QWxsQW5kT3ZlcnJpZGU8Ym9vbGVhbj4oSVNfUFVCTElDX0tFWSwgW1xyXG4gICAgICBjb250ZXh0LmdldEhhbmRsZXIoKSwgLy8gTWV0aG9kZSAoQFB1YmxpYygpIGF1ZiBNZXRob2RlKVxyXG4gICAgICBjb250ZXh0LmdldENsYXNzKCksIC8vIENvbnRyb2xsZXIgKEBQdWJsaWMoKSBhdWYgQ29udHJvbGxlcilcclxuICAgIF0pO1xyXG5cclxuICAgIC8vIDIuIFdlbm4gcHVibGljLCBzb2ZvcnQgZXJsYXViZW4gKGtlaW5lIFRva2VuLVByw7xmdW5nKVxyXG4gICAgaWYgKGlzUHVibGljKSB7XHJcbiAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdQdWJsaWMgcm91dGUgYWNjZXNzZWQsIHNraXBwaW5nIGF1dGhlbnRpY2F0aW9uJyk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIDMuIFdlbm4gbmljaHQgcHVibGljLCBQYXNzcG9ydCBKV1QgU3RyYXRlZ3kgYXVzZsO8aHJlblxyXG4gICAgcmV0dXJuIHN1cGVyLmNhbkFjdGl2YXRlKGNvbnRleHQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogaGFuZGxlUmVxdWVzdCAtIFZlcmFyYmVpdGV0IFBhc3Nwb3J0LUVyZ2VibmlzXHJcbiAgICpcclxuICAgKiBXaXJkIG5hY2ggSnd0U3RyYXRlZ3kudmFsaWRhdGUoKSBhdWZnZXJ1ZmVuXHJcbiAgICogRXJsYXVidCB1bnMsIGRlbiBFcnJvci9Vc2VyIHp1IGN1c3RvbWl6ZW5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBlcnIgLSBFcnJvciB2b24gUGFzc3BvcnQgKG51bGwgd2VubiBlcmZvbGdyZWljaClcclxuICAgKiBAcGFyYW0gdXNlciAtIFVzZXIgdm9uIEp3dFN0cmF0ZWd5LiB2YWxpZGF0ZSgpICh1bmRlZmluZWQgd2VubiBmZWhsZ2VzY2hsYWdlbilcclxuICAgKiBAcGFyYW0gaW5mbyAtIFp1c8OkdHpsaWNoZSBJbmZvICh6LkIuIFwiand0IGV4cGlyZWRcIilcclxuICAgKiBAcmV0dXJucyBVc2VyIHdlbm4gZXJmb2xncmVpY2hcclxuICAgKiBAdGhyb3dzIFVuYXV0aG9yaXplZEV4Y2VwdGlvbiB3ZW5uIGZlaGxnZXNjaGxhZ2VuXHJcbiAgICovXHJcbiAgaGFuZGxlUmVxdWVzdDxUPihlcnI6IEVycm9yIHwgbnVsbCwgdXNlcjogVCwgaW5mbzogRXJyb3IgfCB1bmRlZmluZWQpOiBUIHtcclxuICAgIC8vIFBhc3Nwb3J0IEVycm9yICh6LkIuIGludmFsaWQgc2lnbmF0dXJlKVxyXG4gICAgaWYgKGVycikge1xyXG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBBdXRoZW50aWNhdGlvbiBlcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcclxuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEV4Y2VwdGlvbignQXV0aGVudGljYXRpb24gZmFpbGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gS2VpbiBVc2VyIChUb2tlbiBpbnZhbGlkL2V4cGlyZWQgb2RlciBVc2VyIG5pY2h0IGdlZnVuZGVuKVxyXG4gICAgaWYgKCF1c2VyKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPVxyXG4gICAgICAgIGluZm8/Lm1lc3NhZ2UgfHwgJ0ludmFsaWQgb3IgbWlzc2luZyBhdXRoZW50aWNhdGlvbiB0b2tlbic7XHJcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYEF1dGhlbnRpY2F0aW9uIGZhaWxlZDogJHttZXNzYWdlfWApO1xyXG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXhjZXB0aW9uKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1c2VyO1xyXG4gIH1cclxufVxyXG4iXSwidmVyc2lvbiI6M30=