{"file":"C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\auth\\guards\\jwt-auth.guard.ts","mappings":";AAAA,4CAA4C;;;;;;;;;;;;;;AAE5C,2CAKwB;AACxB,uCAAyC;AACzC,+CAA6C;AAC7C,qEAA+D;AAE/D;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AAEI,IAAM,YAAY,oBAAlB,MAAM,YAAa,SAAQ,IAAA,oBAAS,EAAC,KAAK,CAAC;IAG5B;IAFH,MAAM,GAAG,IAAI,eAAM,CAAC,cAAY,CAAC,IAAI,CAAC,CAAC;IAExD,YAAoB,SAAoB;QACtC,KAAK,EAAE,CAAC;QADU,cAAS,GAAT,SAAS,CAAW;IAExC,CAAC;IAED;;;;;OAKG;IACH,WAAW,CAAC,OAAyB;QACnC,+CAA+C;QAC/C,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAU,gCAAa,EAAE;YACxE,OAAO,CAAC,UAAU,EAAE,EAAE,kCAAkC;YACxD,OAAO,CAAC,QAAQ,EAAE,EAAE,wCAAwC;SAC7D,CAAC,CAAC;QAEH,wDAAwD;QACxD,IAAI,QAAQ,EAAE,CAAC;YACb,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,gDAAgD,CAAC,CAAC;YACpE,OAAO,IAAI,CAAC;QACd,CAAC;QAED,wDAAwD;QACxD,OAAO,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IACpC,CAAC;IAED;;;;;;;;;;;OAWG;IACH,aAAa,CAAI,GAAiB,EAAE,IAAO,EAAE,IAAuB;QAClE,0CAA0C;QAC1C,IAAI,GAAG,EAAE,CAAC;YACR,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,yBAAyB,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YACzD,MAAM,IAAI,8BAAqB,CAAC,uBAAuB,CAAC,CAAC;QAC3D,CAAC;QAED,6DAA6D;QAC7D,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,OAAO,GACX,IAAI,EAAE,OAAO,IAAI,yCAAyC,CAAC;YAC7D,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,0BAA0B,OAAO,EAAE,CAAC,CAAC;YACtD,MAAM,IAAI,8BAAqB,CAAC,OAAO,CAAC,CAAC;QAC3C,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;CACF,CAAA;AA3DY,oCAAY;uBAAZ,YAAY;IADxB,IAAA,mBAAU,GAAE;yDAIoB,gBAAS,oBAAT,gBAAS;GAH7B,YAAY,CA2DxB","names":[],"sources":["C:\\Users\\timur\\Programming\\Projects\\snippetforge\\apps\\api\\src\\modules\\auth\\guards\\jwt-auth.guard.ts"],"sourcesContent":["// src/modules/auth/guards/jwt-auth.guard.ts\r\n\r\nimport {\r\n  ExecutionContext,\r\n  Injectable,\r\n  Logger,\r\n  UnauthorizedException,\r\n} from '@nestjs/common';\r\nimport { Reflector } from '@nestjs/core';\r\nimport { AuthGuard } from '@nestjs/passport';\r\nimport { IS_PUBLIC_KEY } from '../decorators/public.decorator';\r\n\r\n/**\r\n * JwtAuthGuard - Schützt Routes vor unauthentifizierten Zugriffen\r\n *\r\n * WIE ES FUNKTIONIERT:\r\n * 1. Guard wird auf Route/Controller angewendet\r\n * 2. canActivate() wird aufgerufen\r\n * 3. Prüft ob Route @Public() ist → Wenn ja, erlauben\r\n * 4. Wenn nicht public, delegiert an Passport JwtStrategy\r\n * 5. JwtStrategy validiert Token und lädt User\r\n * 6. Wenn erfolgreich:  request.user = User, Route wird ausgeführt\r\n * 7. Wenn fehlgeschlagen: 401 Unauthorized\r\n *\r\n * VERWENDUNG:\r\n *\r\n * // Auf einzelner Route\r\n * @UseGuards(JwtAuthGuard)\r\n * @Get('profile')\r\n * getProfile() {}\r\n *\r\n * // Global auf allen Routes (in main.ts)\r\n * app.useGlobalGuards(new JwtAuthGuard(reflector))\r\n *\r\n * // Route von Auth ausnehmen\r\n * @Public()\r\n * @Get('health')\r\n * healthCheck() {}\r\n */\r\n@Injectable()\r\nexport class JwtAuthGuard extends AuthGuard('jwt') {\r\n  private readonly logger = new Logger(JwtAuthGuard.name);\r\n\r\n  constructor(private reflector: Reflector) {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * canActivate - Entscheidet ob Request durchgelassen wird\r\n   *\r\n   * @param context - Execution Context (enthält Request, Handler, etc.)\r\n   * @returns true wenn erlaubt, false/Exception wenn nicht\r\n   */\r\n  canActivate(context: ExecutionContext) {\r\n    // 1. Prüfe ob Route als @Public() markiert ist\r\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\r\n      context.getHandler(), // Methode (@Public() auf Methode)\r\n      context.getClass(), // Controller (@Public() auf Controller)\r\n    ]);\r\n\r\n    // 2. Wenn public, sofort erlauben (keine Token-Prüfung)\r\n    if (isPublic) {\r\n      this.logger.debug('Public route accessed, skipping authentication');\r\n      return true;\r\n    }\r\n\r\n    // 3. Wenn nicht public, Passport JWT Strategy ausführen\r\n    return super.canActivate(context);\r\n  }\r\n\r\n  /**\r\n   * handleRequest - Verarbeitet Passport-Ergebnis\r\n   *\r\n   * Wird nach JwtStrategy.validate() aufgerufen\r\n   * Erlaubt uns, den Error/User zu customizen\r\n   *\r\n   * @param err - Error von Passport (null wenn erfolgreich)\r\n   * @param user - User von JwtStrategy. validate() (undefined wenn fehlgeschlagen)\r\n   * @param info - Zusätzliche Info (z.B. \"jwt expired\")\r\n   * @returns User wenn erfolgreich\r\n   * @throws UnauthorizedException wenn fehlgeschlagen\r\n   */\r\n  handleRequest<T>(err: Error | null, user: T, info: Error | undefined): T {\r\n    // Passport Error (z.B. invalid signature)\r\n    if (err) {\r\n      this.logger.warn(`Authentication error: ${err.message}`);\r\n      throw new UnauthorizedException('Authentication failed');\r\n    }\r\n\r\n    // Kein User (Token invalid/expired oder User nicht gefunden)\r\n    if (!user) {\r\n      const message =\r\n        info?.message || 'Invalid or missing authentication token';\r\n      this.logger.warn(`Authentication failed: ${message}`);\r\n      throw new UnauthorizedException(message);\r\n    }\r\n\r\n    return user;\r\n  }\r\n}\r\n"],"version":3}