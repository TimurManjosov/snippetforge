{"file":"/home/runner/work/snippetforge/snippetforge/apps/api/src/modules/auth/strategies/jwt.strategy.ts","mappings":";AAAA,8CAA8C;;;;;;;;;;;;;;AAE9C,2CAA2E;AAC3E,2CAA+C;AAC/C,+CAAoD;AACpD,+CAAoD;AACpD,uCAA0D;AAG1D;;;;;;;;;;;;;;;;;;;;;GAqBG;AAEI,IAAM,WAAW,mBAAjB,MAAM,WAAY,SAAQ,IAAA,2BAAgB,EAAC,uBAAQ,CAAC;IAItC;IACA;IAJF,MAAM,GAAG,IAAI,eAAM,CAAC,aAAW,CAAC,IAAI,CAAC,CAAC;IAEvD,YACmB,aAA4B,EAC5B,YAA0B;QAE3C,kCAAkC;QAClC,KAAK,CAAC;YACJ,6DAA6D;YAC7D,cAAc,EAAE,yBAAU,CAAC,2BAA2B,EAAE;YAExD,+BAA+B;YAC/B,gBAAgB,EAAE,KAAK;YAEvB,kCAAkC;YAClC,WAAW,EAAE,aAAa,CAAC,GAAG,CAAS,YAAY,CAAC,IAAI,EAAE;YAE1D,mCAAmC;YACnC,UAAU,EAAE,CAAC,OAAO,CAAC;SACtB,CAAC,CAAC;QAhBc,kBAAa,GAAb,aAAa,CAAe;QAC5B,iBAAY,GAAZ,YAAY,CAAc;IAgB7C,CAAC;IAED;;;;;;;;;;OAUG;IACH,KAAK,CAAC,QAAQ,CAAC,OAAmB;QAChC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,4BAA4B,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;QAE7D,sCAAsC;QACtC,8EAA8E;QAC9E,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAE3D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,2BAA2B,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC;YAC3D,OAAO,IAAI,CAAC;YACZ,6DAA6D;QAC/D,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,kCAAkC;YAClC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,+BAA+B,OAAO,CAAC,GAAG,YAAY,CAAC,CAAC;YACzE,MAAM,IAAI,8BAAqB,CAAC,oCAAoC,CAAC,CAAC;QACxE,CAAC;IACH,CAAC;CACF,CAAA;AAnDY,kCAAW;sBAAX,WAAW;IADvB,IAAA,mBAAU,GAAE;yDAKuB,sBAAa,oBAAb,sBAAa,oDACd,oBAAY,oBAAZ,oBAAY;GALlC,WAAW,CAmDvB","names":[],"sources":["/home/runner/work/snippetforge/snippetforge/apps/api/src/modules/auth/strategies/jwt.strategy.ts"],"sourcesContent":["// src/modules/auth/strategies/jwt.strategy.ts\n\nimport { Injectable, Logger, UnauthorizedException } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { UsersService, type SafeUser } from '../../users';\nimport { type JwtPayload } from '../auth.types';\n\n/**\n * JwtStrategy - Validiert JWT Tokens bei geschützten Routes\n *\n * WIE ES FUNKTIONIERT:\n * 1. Request kommt rein mit Authorization:  Bearer <token>\n * 2. JwtAuthGuard aktiviert diese Strategy\n * 3. passport-jwt extrahiert Token aus Header\n * 4. passport-jwt verifiziert Signatur mit Secret\n * 5. validate() wird mit decoded Payload aufgerufen\n * 6. validate() lädt User aus DB und gibt ihn zurück\n * 7. User wird an request.user angehängt\n *\n * WARUM User aus DB laden statt nur Payload nutzen?\n * - User könnte gelöscht/deaktiviert worden sein\n * - User-Rolle könnte sich geändert haben\n * - Wir brauchen aktuelle User-Daten\n *\n * ALTERNATIVE:  Nur Payload nutzen (ohne DB-Query)\n * Pro: Schneller (kein DB-Roundtrip)\n * Contra: Veraltete Daten möglich\n * Entscheidung: DB-Query für Sicherheit (bei jedem Request)\n */\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  private readonly logger = new Logger(JwtStrategy.name);\n\n  constructor(\n    private readonly configService: ConfigService,\n    private readonly usersService: UsersService,\n  ) {\n    // Passport Strategy Konfiguration\n    super({\n      // Wo ist der Token?  → Authorization Header als Bearer Token\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n\n      // Abgelaufene Tokens ablehnen?\n      ignoreExpiration: false,\n\n      // Secret für Signatur-Validierung\n      secretOrKey: configService.get<string>('JWT_SECRET') || '',\n\n      // Algorithms die akzeptiert werden\n      algorithms: ['HS256'],\n    });\n  }\n\n  /**\n   * Validate - Wird nach erfolgreicher Token-Verifikation aufgerufen\n   *\n   * WICHTIG: Wenn diese Methode einen Wert zurückgibt,\n   * wird dieser an request.user angehängt.\n   * Wenn sie eine Exception wirft, wird 401 zurückgegeben.\n   *\n   * @param payload - Decoded JWT Payload (bereits verifiziert!)\n   * @returns SafeUser für request.user\n   * @throws UnauthorizedException wenn User nicht existiert\n   */\n  async validate(payload: JwtPayload): Promise<SafeUser> {\n    this.logger.debug(`Validating JWT for user: ${payload.sub}`);\n\n    // User aus DB laden (aktuelle Daten!)\n    // Wir nutzen try-catch weil findById eine Exception wirft wenn nicht gefunden\n    try {\n      const user = await this.usersService.findById(payload.sub);\n\n      this.logger.debug(`JWT validated for user: ${user.email}`);\n      return user;\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (error) {\n      // User nicht gefunden (gelöscht?)\n      this.logger.warn(`JWT validation failed: User ${payload.sub} not found`);\n      throw new UnauthorizedException('User not found or has been deleted');\n    }\n  }\n}\n"],"version":3}