{"file":"/home/runner/work/snippetforge/snippetforge/apps/api/src/shared/types/error-response.type.ts","mappings":";AAAA,0CAA0C;;AAqG1C,kDAwBC;AAnCD;;;;;;;;;;GAUG;AACH,SAAgB,mBAAmB,CAAC,MAQnC;IACC,OAAO;QACL,OAAO,EAAE,KAAK;QACd,KAAK,EAAE;YACL,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,OAAO,EAAE,MAAM,CAAC,OAAO;YACvB,UAAU,EAAE,MAAM,CAAC,UAAU;YAC7B,GAAG,CAAC,MAAM,CAAC,OAAO,IAAI,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,CAAC;SACnD;QACD,IAAI,EAAE;YACJ,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;YACnC,IAAI,EAAE,MAAM,CAAC,IAAI;YACjB,MAAM,EAAE,MAAM,CAAC,MAAM;YACrB,GAAG,CAAC,MAAM,CAAC,SAAS,IAAI,EAAE,SAAS,EAAE,MAAM,CAAC,SAAS,EAAE,CAAC;SACzD;KACF,CAAC;AACJ,CAAC","names":[],"sources":["/home/runner/work/snippetforge/snippetforge/apps/api/src/shared/types/error-response.type.ts"],"sourcesContent":["// src/shared/types/error-response.type.ts\n\nimport { type ErrorCode } from '../constants';\n\n/**\n * Standard Error Response Format\n *\n * WARUM dieses Format?\n * 1. Konsistenz: Frontend kann ALLE Errors gleich parsen\n * 2. Debugging: Meta-Daten helfen bei Fehlersuche\n * 3. Machine-Readable: Error Code für programmatische Verarbeitung\n * 4. Human-Readable: Message für Anzeige\n *\n * STRUKTUR:\n * {\n *   success: false,              // Schneller Check\n *   error: {\n *     code: \"AUTH_TOKEN_EXPIRED\", // Machine-readable\n *     message: \"Token expired\",   // Human-readable\n *     statusCode: 401,            // HTTP Status\n *     details?: {...}           // Zusätzliche Infos (Validation Errors)\n *   },\n *   meta: {\n *     timestamp: \"...\",           // Wann der Error auftrat\n *     path: \"/api/auth/me\",       // Welcher Endpoint\n *     method: \"GET\",              // Welche HTTP Methode\n *     requestId?: \"...\"           // Für Tracing (optional)\n *   }\n * }\n */\n\n/**\n * Error Details - Zusätzliche Informationen zum Error\n */\nexport interface ErrorDetails {\n  /** Feld-spezifische Validation Errors */\n  fields?: Record<string, string[]>;\n\n  /** Zusätzliche Kontext-Informationen */\n  context?: Record<string, unknown>;\n}\n\n/**\n * Error Object innerhalb der Response\n */\nexport interface ErrorObject {\n  /** Machine-readable Error Code */\n  code: ErrorCode;\n\n  /** Human-readable Error Message */\n  message: string;\n\n  /** HTTP Status Code */\n  statusCode: number;\n\n  /** Optionale Details (z.B. Validation Errors) */\n  details?: ErrorDetails;\n}\n\n/**\n * Meta-Informationen zur Response\n */\nexport interface ResponseMeta {\n  /** ISO 8601 Timestamp */\n  timestamp: string;\n\n  /** Request Path */\n  path: string;\n\n  /** HTTP Method */\n  method: string;\n\n  /** Request ID für Tracing (falls vorhanden) */\n  requestId?: string;\n}\n\n/**\n * Vollständige Error Response\n */\nexport interface ErrorResponse {\n  /** Immer false bei Errors */\n  success: false;\n\n  /** Error Details */\n  error: ErrorObject;\n\n  /** Meta-Informationen */\n  meta: ResponseMeta;\n}\n\n/**\n * Factory Function für Error Response\n *\n * WARUM Factory statt Constructor?\n * - Einfacher zu verwenden\n * - Keine Klassen-Instanziierung nötig\n * - Bessere Tree-Shaking Möglichkeit\n *\n * @param params - Error Parameter\n * @returns Formatierte Error Response\n */\nexport function createErrorResponse(params: {\n  code: ErrorCode;\n  message: string;\n  statusCode: number;\n  path: string;\n  method: string;\n  details?: ErrorDetails;\n  requestId?: string;\n}): ErrorResponse {\n  return {\n    success: false,\n    error: {\n      code: params.code,\n      message: params.message,\n      statusCode: params.statusCode,\n      ...(params.details && { details: params.details }),\n    },\n    meta: {\n      timestamp: new Date().toISOString(),\n      path: params.path,\n      method: params.method,\n      ...(params.requestId && { requestId: params.requestId }),\n    },\n  };\n}\n"],"version":3}