{"file":"/home/runner/work/snippetforge/snippetforge/apps/api/src/modules/users/users.service.ts","mappings":"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","names":[],"sources":["/home/runner/work/snippetforge/snippetforge/apps/api/src/modules/users/users.service.ts"],"sourcesContent":["// src/modules/users/users.service.ts\n\nimport {\n  ConflictException,\n  Injectable,\n  Logger,\n  NotFoundException,\n} from '@nestjs/common';\nimport * as bcrypt from 'bcryptjs';\nimport { UsersRepository } from './users.repository';\nimport {\n  type CreateUserData,\n  type FullUser,\n  type SafeUser,\n  type UpdateUserData,\n  toFullUser,\n  toSafeUser,\n} from './users.types';\n\n/**\n * UsersService - Business Logic für User-Operationen\n *\n * VERANTWORTLICHKEITEN (Single Responsibility):\n * - Password Hashing/Verification\n * - Business Rules (z.B. \"Email muss unique sein\")\n * - Koordination zwischen Repository und anderen Services\n * - Transformation (DB-Entity → SafeUser)\n *\n * WAS HIER NICHT PASSIERT:\n * - Direkte DB-Queries (→ Repository)\n * - HTTP Response Formatting (→ Controller)\n * - Input Validation (→ Zod Pipes)\n *\n * SECURITY:\n * - Passwords werden HIER gehasht, nicht im Repository\n * - passwordHash wird NIE nach außen gegeben (SafeUser)\n * - Timing-Safe Comparison bei Password-Checks\n */\n\n// Bcrypt Konfiguration\n// 10 Rounds = ~100ms pro Hash auf modernem CPU\n// Guter Kompromiss zwischen Security und Performance\nconst BCRYPT_ROUNDS = 10;\n\n@Injectable()\nexport class UsersService {\n  private readonly logger = new Logger(UsersService.name);\n\n  constructor(private readonly usersRepository: UsersRepository) {}\n\n  // ============================================================\n  // PASSWORD HASHING\n  // ============================================================\n\n  /**\n   * Hasht ein Klartext-Passwort mit bcrypt\n   *\n   * WARUM bcrypt?\n   * - CPU-bound (verhindert GPU-Brute-Force)\n   * - Eingebautes Salting (jeder Hash ist unique)\n   * - Industrie-Standard seit >10 Jahren\n   *\n   * WARUM 10 Rounds?\n   * - <10:  Zu schnell, leichter zu bruteforcen\n   * - >12: Zu langsam, schlechte UX bei Login\n   * - 10: ~100ms, guter Kompromiss\n   *\n   * @param password - Klartext-Passwort\n   * @returns Gehashtes Passwort (60 Zeichen)\n   */\n  async hashPassword(password: string): Promise<string> {\n    return bcrypt.hash(password, BCRYPT_ROUNDS);\n  }\n\n  /**\n   * Vergleicht Klartext-Passwort mit Hash\n   *\n   * SECURITY: bcrypt. compare ist timing-safe\n   * (verhindert Timing-Attacks)\n   *\n   * @param password - Klartext-Passwort vom User\n   * @param hash - Gespeicherter Hash aus DB\n   * @returns true wenn Match, false wenn nicht\n   */\n  async comparePassword(password: string, hash: string): Promise<boolean> {\n    return bcrypt.compare(password, hash);\n  }\n\n  // ============================================================\n  // USER CRUD OPERATIONS\n  // ============================================================\n\n  /**\n   * Erstellt neuen User\n   *\n   * BUSINESS RULES:\n   * 1. Email muss unique sein\n   * 2. Username muss unique sein\n   * 3. Password wird gehasht gespeichert\n   *\n   * @param data - CreateUserData (email, username, password)\n   * @returns SafeUser (ohne passwordHash!)\n   * @throws ConflictException wenn Email/Username existiert\n   */\n  async create(data: CreateUserData): Promise<SafeUser> {\n    this.logger.debug(`Creating user: ${data.email}`);\n\n    // Normalize email for case-insensitive comparison and storage consistency\n    const normalizedEmail = data.email.toLowerCase();\n\n    // 1. Prüfe ob Email oder Username bereits existieren\n    const existingUser = await this.usersRepository.findByEmailOrUsername(\n      normalizedEmail,\n      data.username,\n    );\n\n    if (existingUser) {\n      // Spezifische Fehlermeldung (aber nicht zu spezifisch - Security!)\n      if (existingUser.email === normalizedEmail) {\n        throw new ConflictException('Email is already registered');\n      }\n      throw new ConflictException('Username is already taken');\n    }\n\n    // 2. Password hashen\n    const passwordHash = await this.hashPassword(data.password);\n\n    // 3. User erstellen\n    const user = await this.usersRepository.create({\n      email: normalizedEmail,\n      username: data.username,\n      passwordHash,\n    });\n\n    this.logger.log(`User created: ${user.id}`);\n\n    // 4. SafeUser zurückgeben (OHNE passwordHash!)\n    return toSafeUser(user);\n  }\n\n  /**\n   * Findet User anhand der ID\n   * Gibt SafeUser zurück (ohne passwordHash)\n   *\n   * @param id - UUID des Users\n   * @returns SafeUser\n   * @throws NotFoundException wenn User nicht existiert\n   */\n  async findById(id: string): Promise<SafeUser> {\n    const user = await this.usersRepository.findById(id);\n\n    if (!user) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    return toSafeUser(user);\n  }\n\n  /**\n   * Findet User anhand der Email\n   * Gibt FullUser zurück (MIT passwordHash)\n   *\n   * NUR FÜR AUTHENTICATION VERWENDEN!\n   * Niemals in API Response zurückgeben!\n   *\n   * @param email - Email-Adresse\n   * @returns FullUser oder null wenn nicht gefunden\n   */\n  async findByEmailWithPassword(email: string): Promise<FullUser | null> {\n    const user = await this.usersRepository.findByEmail(email);\n\n    if (!user) {\n      return null;\n    }\n\n    return toFullUser(user);\n  }\n\n  /**\n   * Findet User anhand der Email\n   * Gibt SafeUser zurück (ohne passwordHash)\n   *\n   * @param email - Email-Adresse\n   * @returns SafeUser\n   * @throws NotFoundException wenn User nicht existiert\n   */\n  async findByEmail(email: string): Promise<SafeUser> {\n    const user = await this.usersRepository.findByEmail(email);\n\n    if (!user) {\n      throw new NotFoundException(`User with email ${email} not found`);\n    }\n\n    return toSafeUser(user);\n  }\n\n  /**\n   * Aktualisiert User-Profil\n   *\n   * @param id - UUID des Users\n   * @param data - Zu aktualisierende Felder\n   * @returns Aktualisierter SafeUser\n   * @throws NotFoundException wenn User nicht existiert\n   */\n  async update(id: string, data: UpdateUserData): Promise<SafeUser> {\n    this.logger.debug(`Updating user: ${id}`);\n\n    // Prüfe ob User existiert\n    const existingUser = await this.usersRepository.findById(id);\n    if (!existingUser) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    // Prüfe ob Username bereits von anderem User verwendet wird\n    if (data.username && data.username !== existingUser.username) {\n      const userWithSameUsername = await this.usersRepository.findByUsername(\n        data.username,\n      );\n      if (userWithSameUsername && userWithSameUsername.id !== id) {\n        throw new ConflictException('Username is already taken');\n      }\n    }\n\n    // Update durchführen\n    const updatedUser = await this.usersRepository.update(id, data);\n\n    // Sollte nie null sein (wir haben gerade geprüft), aber Defensive Programming\n    if (!updatedUser) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    this.logger.log(`User updated: ${id}`);\n    return toSafeUser(updatedUser);\n  }\n\n  /**\n   * Ändert User-Passwort\n   *\n   * SECURITY:\n   * - Altes Passwort muss korrekt sein\n   * - Neues Passwort wird gehasht\n   *\n   * @param id - UUID des Users\n   * @param currentPassword - Aktuelles Passwort (Klartext)\n   * @param newPassword - Neues Passwort (Klartext)\n   * @returns true wenn erfolgreich\n   * @throws NotFoundException wenn User nicht existiert\n   * @throws ConflictException wenn aktuelles Passwort falsch\n   */\n  async changePassword(\n    id: string,\n    currentPassword: string,\n    newPassword: string,\n  ): Promise<boolean> {\n    this.logger.debug(`Changing password for user: ${id}`);\n\n    // 1. User mit passwordHash laden\n    const user = await this.usersRepository.findById(id);\n    if (!user) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    // 2. Aktuelles Passwort prüfen\n    const isCurrentPasswordValid = await this.comparePassword(\n      currentPassword,\n      user.passwordHash,\n    );\n\n    if (!isCurrentPasswordValid) {\n      throw new ConflictException('Current password is incorrect');\n    }\n\n    // 3. Neues Passwort hashen und speichern\n    const newPasswordHash = await this.hashPassword(newPassword);\n    await this.usersRepository.updatePassword(id, newPasswordHash);\n\n    this.logger.log(`Password changed for user: ${id}`);\n    return true;\n  }\n\n  /**\n   * Löscht User\n   *\n   * @param id - UUID des Users\n   * @returns true wenn erfolgreich\n   * @throws NotFoundException wenn User nicht existiert\n   */\n  async delete(id: string): Promise<boolean> {\n    this.logger.debug(`Deleting user: ${id}`);\n\n    const deleted = await this.usersRepository.delete(id);\n\n    if (!deleted) {\n      throw new NotFoundException(`User with ID ${id} not found`);\n    }\n\n    this.logger.log(`User deleted: ${id}`);\n    return true;\n  }\n\n  // ============================================================\n  // VALIDATION HELPERS (für AuthService)\n  // ============================================================\n\n  /**\n   * Validiert User-Credentials\n   * Verwendet bei Login\n   *\n   * SECURITY:\n   * - Gibt null zurück bei JEDEM Fehler (Email nicht gefunden ODER Password falsch)\n   * - Verhindert User Enumeration\n   *\n   * @param email - Email-Adresse\n   * @param password - Klartext-Passwort\n   * @returns SafeUser wenn valide, null wenn nicht\n   */\n  async validateCredentials(\n    email: string,\n    password: string,\n  ): Promise<SafeUser | null> {\n    // 1. User laden (mit passwordHash)\n    const user = await this.findByEmailWithPassword(email);\n\n    if (!user) {\n      // User nicht gefunden - aber wir verraten das nicht!\n      // Stattdessen führen wir trotzdem einen Hash-Vergleich durch\n      // (verhindert Timing-Attacks)\n      // Real bcrypt hash (10 rounds) for consistent timing characteristics\n      await this.comparePassword(\n        password,\n        '$2b$10$tfim3AUyYJJ.b1Cjz4jUn.NJ4JiCMCJYS7FotrpAKOAk2r6rjrQDe',\n      );\n      return null;\n    }\n\n    // 2. Password vergleichen\n    const isPasswordValid = await this.comparePassword(\n      password,\n      user.passwordHash,\n    );\n\n    if (!isPasswordValid) {\n      return null;\n    }\n\n    // 3. SafeUser zurückgeben (ohne passwordHash!)\n    return toSafeUser(user);\n  }\n}\n"],"version":3}