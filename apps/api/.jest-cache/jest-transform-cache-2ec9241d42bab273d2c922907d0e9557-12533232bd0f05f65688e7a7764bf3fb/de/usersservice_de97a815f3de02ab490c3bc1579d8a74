ec49e8216c6f13b4571d25090be0e9b3
"use strict";
// src/modules/users/users.service.ts
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UsersService_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersService = void 0;
const common_1 = require("@nestjs/common");
const bcrypt = __importStar(require("bcryptjs"));
const users_repository_1 = require("./users.repository");
const users_types_1 = require("./users.types");
/**
 * UsersService - Business Logic für User-Operationen
 *
 * VERANTWORTLICHKEITEN (Single Responsibility):
 * - Password Hashing/Verification
 * - Business Rules (z.B. "Email muss unique sein")
 * - Koordination zwischen Repository und anderen Services
 * - Transformation (DB-Entity → SafeUser)
 *
 * WAS HIER NICHT PASSIERT:
 * - Direkte DB-Queries (→ Repository)
 * - HTTP Response Formatting (→ Controller)
 * - Input Validation (→ Zod Pipes)
 *
 * SECURITY:
 * - Passwords werden HIER gehasht, nicht im Repository
 * - passwordHash wird NIE nach außen gegeben (SafeUser)
 * - Timing-Safe Comparison bei Password-Checks
 */
// Bcrypt Konfiguration
// 10 Rounds = ~100ms pro Hash auf modernem CPU
// Guter Kompromiss zwischen Security und Performance
const BCRYPT_ROUNDS = 10;
let UsersService = UsersService_1 = class UsersService {
    usersRepository;
    logger = new common_1.Logger(UsersService_1.name);
    constructor(usersRepository) {
        this.usersRepository = usersRepository;
    }
    // ============================================================
    // PASSWORD HASHING
    // ============================================================
    /**
     * Hasht ein Klartext-Passwort mit bcrypt
     *
     * WARUM bcrypt?
     * - CPU-bound (verhindert GPU-Brute-Force)
     * - Eingebautes Salting (jeder Hash ist unique)
     * - Industrie-Standard seit >10 Jahren
     *
     * WARUM 10 Rounds?
     * - <10:  Zu schnell, leichter zu bruteforcen
     * - >12: Zu langsam, schlechte UX bei Login
     * - 10: ~100ms, guter Kompromiss
     *
     * @param password - Klartext-Passwort
     * @returns Gehashtes Passwort (60 Zeichen)
     */
    async hashPassword(password) {
        return bcrypt.hash(password, BCRYPT_ROUNDS);
    }
    /**
     * Vergleicht Klartext-Passwort mit Hash
     *
     * SECURITY: bcrypt. compare ist timing-safe
     * (verhindert Timing-Attacks)
     *
     * @param password - Klartext-Passwort vom User
     * @param hash - Gespeicherter Hash aus DB
     * @returns true wenn Match, false wenn nicht
     */
    async comparePassword(password, hash) {
        return bcrypt.compare(password, hash);
    }
    // ============================================================
    // USER CRUD OPERATIONS
    // ============================================================
    /**
     * Erstellt neuen User
     *
     * BUSINESS RULES:
     * 1. Email muss unique sein
     * 2. Username muss unique sein
     * 3. Password wird gehasht gespeichert
     *
     * @param data - CreateUserData (email, username, password)
     * @returns SafeUser (ohne passwordHash!)
     * @throws ConflictException wenn Email/Username existiert
     */
    async create(data) {
        this.logger.debug(`Creating user: ${data.email}`);
        // Normalize email for case-insensitive comparison and storage consistency
        const normalizedEmail = data.email.toLowerCase();
        // 1. Prüfe ob Email oder Username bereits existieren
        const existingUser = await this.usersRepository.findByEmailOrUsername(normalizedEmail, data.username);
        if (existingUser) {
            // Spezifische Fehlermeldung (aber nicht zu spezifisch - Security!)
            if (existingUser.email === normalizedEmail) {
                throw new common_1.ConflictException('Email is already registered');
            }
            throw new common_1.ConflictException('Username is already taken');
        }
        // 2. Password hashen
        const passwordHash = await this.hashPassword(data.password);
        // 3. User erstellen
        const user = await this.usersRepository.create({
            email: normalizedEmail,
            username: data.username,
            passwordHash,
        });
        this.logger.log(`User created: ${user.id}`);
        // 4. SafeUser zurückgeben (OHNE passwordHash!)
        return (0, users_types_1.toSafeUser)(user);
    }
    /**
     * Findet User anhand der ID
     * Gibt SafeUser zurück (ohne passwordHash)
     *
     * @param id - UUID des Users
     * @returns SafeUser
     * @throws NotFoundException wenn User nicht existiert
     */
    async findById(id) {
        const user = await this.usersRepository.findById(id);
        if (!user) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        return (0, users_types_1.toSafeUser)(user);
    }
    /**
     * Findet User anhand der Email
     * Gibt FullUser zurück (MIT passwordHash)
     *
     * NUR FÜR AUTHENTICATION VERWENDEN!
     * Niemals in API Response zurückgeben!
     *
     * @param email - Email-Adresse
     * @returns FullUser oder null wenn nicht gefunden
     */
    async findByEmailWithPassword(email) {
        const user = await this.usersRepository.findByEmail(email);
        if (!user) {
            return null;
        }
        return (0, users_types_1.toFullUser)(user);
    }
    /**
     * Findet User anhand der Email
     * Gibt SafeUser zurück (ohne passwordHash)
     *
     * @param email - Email-Adresse
     * @returns SafeUser
     * @throws NotFoundException wenn User nicht existiert
     */
    async findByEmail(email) {
        const user = await this.usersRepository.findByEmail(email);
        if (!user) {
            throw new common_1.NotFoundException(`User with email ${email} not found`);
        }
        return (0, users_types_1.toSafeUser)(user);
    }
    /**
     * Aktualisiert User-Profil
     *
     * @param id - UUID des Users
     * @param data - Zu aktualisierende Felder
     * @returns Aktualisierter SafeUser
     * @throws NotFoundException wenn User nicht existiert
     */
    async update(id, data) {
        this.logger.debug(`Updating user: ${id}`);
        // Prüfe ob User existiert
        const existingUser = await this.usersRepository.findById(id);
        if (!existingUser) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        // Prüfe ob Username bereits von anderem User verwendet wird
        if (data.username && data.username !== existingUser.username) {
            const userWithSameUsername = await this.usersRepository.findByUsername(data.username);
            if (userWithSameUsername && userWithSameUsername.id !== id) {
                throw new common_1.ConflictException('Username is already taken');
            }
        }
        // Update durchführen
        const updatedUser = await this.usersRepository.update(id, data);
        // Sollte nie null sein (wir haben gerade geprüft), aber Defensive Programming
        if (!updatedUser) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        this.logger.log(`User updated: ${id}`);
        return (0, users_types_1.toSafeUser)(updatedUser);
    }
    /**
     * Ändert User-Passwort
     *
     * SECURITY:
     * - Altes Passwort muss korrekt sein
     * - Neues Passwort wird gehasht
     *
     * @param id - UUID des Users
     * @param currentPassword - Aktuelles Passwort (Klartext)
     * @param newPassword - Neues Passwort (Klartext)
     * @returns true wenn erfolgreich
     * @throws NotFoundException wenn User nicht existiert
     * @throws ConflictException wenn aktuelles Passwort falsch
     */
    async changePassword(id, currentPassword, newPassword) {
        this.logger.debug(`Changing password for user: ${id}`);
        // 1. User mit passwordHash laden
        const user = await this.usersRepository.findById(id);
        if (!user) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        // 2. Aktuelles Passwort prüfen
        const isCurrentPasswordValid = await this.comparePassword(currentPassword, user.passwordHash);
        if (!isCurrentPasswordValid) {
            throw new common_1.ConflictException('Current password is incorrect');
        }
        // 3. Neues Passwort hashen und speichern
        const newPasswordHash = await this.hashPassword(newPassword);
        await this.usersRepository.updatePassword(id, newPasswordHash);
        this.logger.log(`Password changed for user: ${id}`);
        return true;
    }
    /**
     * Löscht User
     *
     * @param id - UUID des Users
     * @returns true wenn erfolgreich
     * @throws NotFoundException wenn User nicht existiert
     */
    async delete(id) {
        this.logger.debug(`Deleting user: ${id}`);
        const deleted = await this.usersRepository.delete(id);
        if (!deleted) {
            throw new common_1.NotFoundException(`User with ID ${id} not found`);
        }
        this.logger.log(`User deleted: ${id}`);
        return true;
    }
    // ============================================================
    // VALIDATION HELPERS (für AuthService)
    // ============================================================
    /**
     * Validiert User-Credentials
     * Verwendet bei Login
     *
     * SECURITY:
     * - Gibt null zurück bei JEDEM Fehler (Email nicht gefunden ODER Password falsch)
     * - Verhindert User Enumeration
     *
     * @param email - Email-Adresse
     * @param password - Klartext-Passwort
     * @returns SafeUser wenn valide, null wenn nicht
     */
    async validateCredentials(email, password) {
        // 1. User laden (mit passwordHash)
        const user = await this.findByEmailWithPassword(email);
        if (!user) {
            // User nicht gefunden - aber wir verraten das nicht!
            // Stattdessen führen wir trotzdem einen Hash-Vergleich durch
            // (verhindert Timing-Attacks)
            // Real bcrypt hash (10 rounds) for consistent timing characteristics
            await this.comparePassword(password, '$2b$10$tfim3AUyYJJ.b1Cjz4jUn.NJ4JiCMCJYS7FotrpAKOAk2r6rjrQDe');
            return null;
        }
        // 2. Password vergleichen
        const isPasswordValid = await this.comparePassword(password, user.passwordHash);
        if (!isPasswordValid) {
            return null;
        }
        // 3. SafeUser zurückgeben (ohne passwordHash!)
        return (0, users_types_1.toSafeUser)(user);
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = UsersService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof users_repository_1.UsersRepository !== "undefined" && users_repository_1.UsersRepository) === "function" ? _a : Object])
], UsersService);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvc25pcHBldGZvcmdlL3NuaXBwZXRmb3JnZS9hcHBzL2FwaS9zcmMvbW9kdWxlcy91c2Vycy91c2Vycy5zZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7QUFBQSxxQ0FBcUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXJDLDJDQUt3QjtBQUN4QixpREFBbUM7QUFDbkMseURBQXFEO0FBQ3JELCtDQU91QjtBQUV2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBRUgsdUJBQXVCO0FBQ3ZCLCtDQUErQztBQUMvQyxxREFBcUQ7QUFDckQsTUFBTSxhQUFhLEdBQUcsRUFBRSxDQUFDO0FBR2xCLElBQU0sWUFBWSxvQkFBbEIsTUFBTSxZQUFZO0lBR007SUFGWixNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsY0FBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXhELFlBQTZCLGVBQWdDO1FBQWhDLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtJQUFHLENBQUM7SUFFakUsK0RBQStEO0lBQy9ELG1CQUFtQjtJQUNuQiwrREFBK0Q7SUFFL0Q7Ozs7Ozs7Ozs7Ozs7OztPQWVHO0lBQ0gsS0FBSyxDQUFDLFlBQVksQ0FBQyxRQUFnQjtRQUNqQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUFDLFFBQWdCLEVBQUUsSUFBWTtRQUNsRCxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCwrREFBK0Q7SUFDL0QsdUJBQXVCO0lBQ3ZCLCtEQUErRDtJQUUvRDs7Ozs7Ozs7Ozs7T0FXRztJQUNILEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBb0I7UUFDL0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsa0JBQWtCLElBQUksQ0FBQyxL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QVdHO0lBQ0gsS0FBSyxDQUFDLG1CQUFtQixDQUN2QixLQUFhLEVBQ2IsUUFBZ0I7UUFFaEIsbUNBQW1DO1FBQ25DLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLHVCQUF1QixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXZELElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNWLHFEQUFxRDtZQUNyRCw2REFBNkQ7WUFDN0QsOEJBQThCO1lBQzlCLHFFQUFxRTtZQUNyRSxNQUFNLElBQUksQ0FBQyxlQUFlLENBQ3hCLFFBQVEsRUFDUiw4REFBOEQsQ0FDL0QsQ0FBQztZQUNGLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELDBCQUEwQjtRQUMxQixNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQ2hELFFBQVEsRUFDUixJQUFJLENBQUMsWUFBWSxDQUNsQixDQUFDO1FBRUYsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3JCLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELCtDQUErQztRQUMvQyxPQUFPLElBQUEsd0JBQVUsRUFBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixDQUFDO0NBQ0YsQ0FBQTtBQS9TWSxvQ0FBWTt1QkFBWixZQUFZO0lBRHhCLElBQUEsbUJBQVUsR0FBRTt5REFJbUMsa0NBQWUsb0JBQWYsa0NBQWU7R0FIbEQsWUFBWSxDQStTeEIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvcnVubmVyL3dvcmsvc25pcHBldGZvcmdlL3NuaXBwZXRmb3JnZS9hcHBzL2FwaS9zcmMvbW9kdWxlcy91c2Vycy91c2Vycy5zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9tb2R1bGVzL3VzZXJzL3VzZXJzLnNlcnZpY2UudHNcblxuaW1wb3J0IHtcbiAgQ29uZmxpY3RFeGNlcHRpb24sXG4gIEluamVjdGFibGUsXG4gIExvZ2dlcixcbiAgTm90Rm91bmRFeGNlcHRpb24sXG59IGZyb20gJ0BuZXN0anMvY29tbW9uJztcbmltcG9ydCAqIGFzIGJjcnlwdCBmcm9tICdiY3J5cHRqcyc7XG5pbXBvcnQgeyBVc2Vyc1JlcG9zaXRvcnkgfSBmcm9tICcuL3VzZXJzLnJlcG9zaXRvcnknO1xuaW1wb3J0IHtcbiAgdHlwZSBDcmVhdGVVc2VyRGF0YSxcbiAgdHlwZSBGdWxsVXNlcixcbiAgdHlwZSBTYWZlVXNlcixcbiAgdHlwZSBVcGRhdGVVc2VyRGF0YSxcbiAgdG9GdWxsVXNlcixcbiAgdG9TYWZlVXNlcixcbn0gZnJvbSAnLi91c2Vycy50eXBlcyc7XG5cbi8qKlxuICogVXNlcnNTZXJ2aWNlIC0gQnVzaW5lc3MgTG9naWMgZsO8ciBVc2VyLU9wZXJhdGlvbmVuXG4gKlxuICogVkVSQU5UV09SVExJQ0hLRUlURU4gKFNpbmdsZSBSZXNwb25zaWJpbGl0eSk6XG4gKiAtIFBhc3N3b3JkIEhhc2hpbmcvVmVyaWZpY2F0aW9uXG4gKiAtIEJ1c2luZXNzIFJ1bGVzICh6LkIuIFwiRW1haWwgbXVzcyB1bmlxdWUgc2VpblwiKVxuICogLSBLb29yZGluYXRpb24gendpc2NoZW4gUmVwb3NpdG9yeSB1bmQgYW5kZXJlbiBTZXJ2aWNlc1xuICogLSBUcmFuc2Zvcm1hdGlvbiAoREItRW50aXR5IOKGkiBTYWZlVXNlcilcbiAqXG4gKiBXQVMgSElFUiBOSUNIVCBQQVNTSUVSVDpcbiAqIC0gRGlyZWt0ZSBEQi1RdWVyaWVzICjihpIgUmVwb3NpdG9yeSlcbiAqIC0gSFRUUCBSZXNwb25zZSBGb3JtYXR0aW5nICjihpIgQ29udHJvbGxlcilcbiAqIC0gSW5wdXQgVmFsaWRhdGlvbiAo4oaSIFpvZCBQaXBlcylcbiAqXG4gKiBTRUNVUklUWTpcbiAqIC0gUGFzc3dvcmRzIHdlcmRlbiBISUVSIGdlaGFzaHQsIG5pY2h0IGltIFJlcG9zaXRvcnlcbiAqIC0gcGFzc3dvcmRIYXNoIHdpcmQgTklFIG5hY2ggYXXDn2VuIGdlZ2ViZW4gKFNhZmVVc2VyKVxuICogLSBUaW1pbmctU2FmZSBDb21wYXJpc29uIGJlaSBQYXNzd29yZC1DaGVja3NcbiAqL1xuXG4vLyBCY3J5cHQgS29uZmlndXJhdGlvblxuLy8gMTAgUm91bmRzID0gfjEwMG1zIHBybyBIYXNoIGF1ZiBtb2Rlcm5lbSBDUFVcbi8vIEd1dGVyIEtvbXByb21pc3Mgendpc2NoZW4gU2VjdXJpdHkgdW5kIFBlcmZvcm1hbmNlXG5jb25zdCBCQ1JZUFRfUk9VTkRTID0gMTA7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBVc2Vyc1NlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoVXNlcnNTZXJ2aWNlLm5hbWUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgdXNlcnNSZXBvc2l0b3J5OiBVc2Vyc1JlcG9zaXRvcnkpIHt9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFBBU1NXT1JEIEhBU0hJTkdcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEhhc2h0IGVpbiBLbGFydGV4dC1QYXNzd29ydCBtaXQgYmNyeXB0XG4gICAqXG4gICAqIFdBUlVNIGJjcnlwdD9cbiAgICogLSBDUFUtYm91bmQgKHZlcmhpbmRlcnQgR1BVLUJydXRlLUZvcmNlKVxuICAgKiAtIEVpbmdlYmF1dGVzIFNhbHRpbmcgKGplZGVyIEhhc2ggaXN0IHVuaXF1ZSlcbiAgICogLSBJbmR1c3RyaWUtU3RhbmRhcmQgc2VpdCA+MTAgSmFocmVuXG4gICAqXG4gICAqIFdBUlVNIDEwIFJvdW5kcz9cbiAgICogLSA8MTA6ICBadSBzY2huZWxsLCBsZWljaHRlciB6dSBicnV0ZWZvcmNlblxuICAgKiAtID4xMjogWnUgbGFuZ3NhbSwgc2NobGVjaHRlIFVYIGJlaSBMb2dpblxuICAgKiAtIDEwOiB+MTAwbXMsIGd1dGVyIEtvbXByb21pc3NcbiAgICpcbiAgICogQHBhcmFtIHBhc3N3b3JkIC0gS2xhcnRleHQtUGFzc3dvcnRcbiAgICogQHJldHVybnMgR2VoYXNodGVzIFBhc3N3b3J0ICg2MCBaZWljaGVuKVxuICAgKi9cbiAgYXN5bmMgaGFzaFBhc3N3b3JkKHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBiY3J5cHQuaGFzaChwYXNzd29yZCwgQkNSWVBUX1JPVU5EUyk7XG4gIH1cblxuICAvKipcbiAgICogVmVyZ2xlaWNodCBLbGFydGV4dC1QYXNzd29ydCBtaXQgSGFzaFxuICAgKlxuICAgKiBTRUNVUklUWTogYmNyeXB0LiBjb21wYXJlIGlzdCB0aW1pbmctc2FmZVxuICAgKiAodmVyaGluZGVydCBUaW1pbmctQXR0YWNrcylcbiAgICpcbiAgICogQHBhcmFtIHBhc3N3b3JkIC0gS2xhcnRleHQtUGFzc3dvcnQgdm9tIFVzZXJcbiAgICogQHBhcmFtIGhhc2ggLSBHZXNwZWljaGVydGVyIEhhc2ggYXVzIERCXG4gICAqIEByZXR1cm5zIHRydWUgd2VubiBNYXRjaCwgZmFsc2Ugd2VubiBuaWNodFxuICAgKi9cbiAgYXN5bmMgY29tcGFyZVBhc3N3b3JkKHBhc3N3b3JkOiBzdHJpbmcsIGhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBiY3J5cHQuY29tcGFyZShwYXNzd29yZCwgaGFzaCk7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVVNFUiBDUlVEIE9QRVJBVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEVyc3RlbGx0IG5ldWVuIFVzZXJcbiAgICpcbiAgICogQlVTSU5FU1MgUlVMRVM6XG4gICAqIDEuIEVtYWlsIG11c3MgdW5pcXVlIHNlaW5cbiAgICogMi4gVXNlcm5hbWUgbXVzcyB1bmlxdWUgc2VpblxuICAgKiAzLiBQYXNzd29yZCB3aXJkIGdlaGFzaHQgZ2VzcGVpY2hlcnRcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBDcmVhdGVVc2VyRGF0YSAoZW1haWwsIHVzZXJuYW1lLCBwYXNzd29yZClcbiAgICogQHJldHVybnMgU2FmZVVzZXIgKG9obmUgcGFzc3dvcmRIYXNoISlcbiAgICogQHRocm93cyBDb25mbGljdEV4Y2VwdGlvbiB3ZW5uIEVtYWlsL1VzZXJuYW1lIGV4aXN0aWVydFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKGRhdGE6IENyZWF0ZVVzZXJEYXRhKTogUHJvbWlzZTxTYWZlVXNlcj4ge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBDcmVhdGluZyB1c2VyOiAke2RhdGEuZW1haWx9YCk7XG5cbiAgICAvLyBOb3JtYWxpemUgZW1haWwgZm9yIGNhc2UtaW5zZW5zaXRpdmUgY29tcGFyaXNvbiBhbmQgc3RvcmFnZSBjb25zaXN0ZW5jeVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRFbWFpbCA9IGRhdGEuZW1haWwudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIDEuIFByw7xmZSBvYiBFbWFpbCBvZGVyIFVzZXJuYW1lIGJlcmVpdHMgZXhpc3RpZXJlblxuICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeUVtYWlsT3JVc2VybmFtZShcbiAgICAgIG5vcm1hbGl6ZWRFbWFpbCxcbiAgICAgIGRhdGEudXNlcm5hbWUsXG4gICAgKTtcblxuICAgIGlmIChleGlzdGluZ1VzZXIpIHtcbiAgICAgIC8vIFNwZXppZmlzY2hlIEZlaGxlcm1lbGR1bmcgKGFiZXIgbmljaHQgenUgc3BlemlmaXNjaCAtIFNlY3VyaXR5ISlcbiAgICAgIGlmIChleGlzdGluZ1VzZXIuZW1haWwgPT09IG5vcm1hbGl6ZWRFbWFpbCkge1xuICAgICAgICB0aHJvdyBuZXcgQ29uZmxpY3RFeGNlcHRpb24oJ0VtYWlsIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKCdVc2VybmFtZSBpcyBhbHJlYWR5IHRha2VuJyk7XG4gICAgfVxuXG4gICAgLy8gMi4gUGFzc3dvcmQgaGFzaGVuXG4gICAgY29uc3QgcGFzc3dvcmRIYXNoID0gYXdhaXQgdGhpcy5oYXNoUGFzc3dvcmQoZGF0YS5wYXNzd29yZCk7XG5cbiAgICAvLyAzLiBVc2VyIGVyc3RlbGxlblxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJzUmVwb3NpdG9yeS5jcmVhdGUoe1xuICAgICAgZW1haWw6IG5vcm1hbGl6ZWRFbWFpbCxcbiAgICAgIHVzZXJuYW1lOiBkYXRhLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmRIYXNoLFxuICAgIH0pO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKGBVc2VyIGNyZWF0ZWQ6ICR7dXNlci5pZH1gKTtcblxuICAgIC8vIDQuIFNhZmVVc2VyIHp1csO8Y2tnZWJlbiAoT0hORSBwYXNzd29yZEhhc2ghKVxuICAgIHJldHVybiB0b1NhZmVVc2VyKHVzZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRldCBVc2VyIGFuaGFuZCBkZXIgSURcbiAgICogR2lidCBTYWZlVXNlciB6dXLDvGNrIChvaG5lIHBhc3N3b3JkSGFzaClcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVVVJRCBkZXMgVXNlcnNcbiAgICogQHJldHVybnMgU2FmZVVzZXJcbiAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiB3ZW5uIFVzZXIgbmljaHQgZXhpc3RpZXJ0XG4gICAqL1xuICBhc3luYyBmaW5kQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxTYWZlVXNlcj4ge1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJzUmVwb3NpdG9yeS5maW5kQnlJZChpZCk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgVXNlciB3aXRoIElEICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIHJldHVybiB0b1NhZmVVc2VyKHVzZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRldCBVc2VyIGFuaGFuZCBkZXIgRW1haWxcbiAgICogR2lidCBGdWxsVXNlciB6dXLDvGNrIChNSVQgcGFzc3dvcmRIYXNoKVxuICAgKlxuICAgKiBOVVIgRsOcUiBBVVRIRU5USUNBVElPTiBWRVJXRU5ERU4hXG4gICAqIE5pZW1hbHMgaW4gQVBJIFJlc3BvbnNlIHp1csO8Y2tnZWJlbiFcbiAgICpcbiAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwtQWRyZXNzZVxuICAgKiBAcmV0dXJucyBGdWxsVXNlciBvZGVyIG51bGwgd2VubiBuaWNodCBnZWZ1bmRlblxuICAgKi9cbiAgYXN5bmMgZmluZEJ5RW1haWxXaXRoUGFzc3dvcmQoZW1haWw6IHN0cmluZyk6IFByb21pc2U8RnVsbFVzZXIgfCBudWxsPiB7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeUVtYWlsKGVtYWlsKTtcblxuICAgIGlmICghdXNlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvRnVsbFVzZXIodXNlcik7XG4gIH1cblxuICAvKipcbiAgICogRmluZGV0IFVzZXIgYW5oYW5kIGRlciBFbWFpbFxuICAgKiBHaWJ0IFNhZmVVc2VyIHp1csO8Y2sgKG9obmUgcGFzc3dvcmRIYXNoKVxuICAgKlxuICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbC1BZHJlc3NlXG4gICAqIEByZXR1cm5zIFNhZmVVc2VyXG4gICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gd2VubiBVc2VyIG5pY2h0IGV4aXN0aWVydFxuICAgKi9cbiAgYXN5bmMgZmluZEJ5RW1haWwoZW1haWw6IHN0cmluZyk6IFByb21pc2U8U2FmZVVzZXI+IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy51c2Vyc1JlcG9zaXRvcnkuZmluZEJ5RW1haWwoZW1haWwpO1xuXG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oYFVzZXIgd2l0aCBlbWFpbCAke2VtYWlsfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9TYWZlVXNlcih1c2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBa3R1YWxpc2llcnQgVXNlci1Qcm9maWxcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVVVJRCBkZXMgVXNlcnNcbiAgICogQHBhcmFtIGRhdGEgLSBadSBha3R1YWxpc2llcmVuZGUgRmVsZGVyXG4gICAqIEByZXR1cm5zIEFrdHVhbGlzaWVydGVyIFNhZmVVc2VyXG4gICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gd2VubiBVc2VyIG5pY2h0IGV4aXN0aWVydFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlKGlkOiBzdHJpbmcsIGRhdGE6IFVwZGF0ZVVzZXJEYXRhKTogUHJvbWlzZTxTYWZlVXNlcj4ge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBVcGRhdGluZyB1c2VyOiAke2lkfWApO1xuXG4gICAgLy8gUHLDvGZlIG9iIFVzZXIgZXhpc3RpZXJ0XG4gICAgY29uc3QgZXhpc3RpbmdVc2VyID0gYXdhaXQgdGhpcy51c2Vyc1JlcG9zaXRvcnkuZmluZEJ5SWQoaWQpO1xuICAgIGlmICghZXhpc3RpbmdVc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oYFVzZXIgd2l0aCBJRCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICAvLyBQcsO8ZmUgb2IgVXNlcm5hbWUgYmVyZWl0cyB2b24gYW5kZXJlbSBVc2VyIHZlcndlbmRldCB3aXJkXG4gICAgaWYgKGRhdGEudXNlcm5hbWUgJiYgZGF0YS51c2VybmFtZSAhPT0gZXhpc3RpbmdVc2VyLnVzZXJuYW1lKSB7XG4gICAgICBjb25zdCB1c2VyV2l0aFNhbWVVc2VybmFtZSA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeVVzZXJuYW1lKFxuICAgICAgICBkYXRhLnVzZXJuYW1lLFxuICAgICAgKTtcbiAgICAgIGlmICh1c2VyV2l0aFNhbWVVc2VybmFtZSAmJiB1c2VyV2l0aFNhbWVVc2VybmFtZS5pZCAhPT0gaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKCdVc2VybmFtZSBpcyBhbHJlYWR5IHRha2VuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGR1cmNoZsO8aHJlblxuICAgIGNvbnN0IHVwZGF0ZWRVc2VyID0gYXdhaXQgdGhpcy51c2Vyc1JlcG9zaXRvcnkudXBkYXRlKGlkLCBkYXRhKTtcblxuICAgIC8vIFNvbGx0ZSBuaWUgbnVsbCBzZWluICh3aXIgaGFiZW4gZ2VyYWRlIGdlcHLDvGZ0KSwgYWJlciBEZWZlbnNpdmUgUHJvZ3JhbW1pbmdcbiAgICBpZiAoIXVwZGF0ZWRVc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oYFVzZXIgd2l0aCBJRCAke2lkfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coYFVzZXIgdXBkYXRlZDogJHtpZH1gKTtcbiAgICByZXR1cm4gdG9TYWZlVXNlcih1cGRhdGVkVXNlcik7XG4gIH1cblxuICAvKipcbiAgICogw4RuZGVydCBVc2VyLVBhc3N3b3J0XG4gICAqXG4gICAqIFNFQ1VSSVRZOlxuICAgKiAtIEFsdGVzIFBhc3N3b3J0IG11c3Mga29ycmVrdCBzZWluXG4gICAqIC0gTmV1ZXMgUGFzc3dvcnQgd2lyZCBnZWhhc2h0XG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFVVSUQgZGVzIFVzZXJzXG4gICAqIEBwYXJhbSBjdXJyZW50UGFzc3dvcmQgLSBBa3R1ZWxsZXMgUGFzc3dvcnQgKEtsYXJ0ZXh0KVxuICAgKiBAcGFyYW0gbmV3UGFzc3dvcmQgLSBOZXVlcyBQYXNzd29ydCAoS2xhcnRleHQpXG4gICAqIEByZXR1cm5zIHRydWUgd2VubiBlcmZvbGdyZWljaFxuICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIHdlbm4gVXNlciBuaWNodCBleGlzdGllcnRcbiAgICogQHRocm93cyBDb25mbGljdEV4Y2VwdGlvbiB3ZW5uIGFrdHVlbGxlcyBQYXNzd29ydCBmYWxzY2hcbiAgICovXG4gIGFzeW5jIGNoYW5nZVBhc3N3b3JkKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgY3VycmVudFBhc3N3b3JkOiBzdHJpbmcsXG4gICAgbmV3UGFzc3dvcmQ6IHN0cmluZyxcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoYENoYW5naW5nIHBhc3N3b3JkIGZvciB1c2VyOiAke2lkfWApO1xuXG4gICAgLy8gMS4gVXNlciBtaXQgcGFzc3dvcmRIYXNoIGxhZGVuXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmZpbmRCeUlkKGlkKTtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgVXNlciB3aXRoIElEICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIC8vIDIuIEFrdHVlbGxlcyBQYXNzd29ydCBwcsO8ZmVuXG4gICAgY29uc3QgaXNDdXJyZW50UGFzc3dvcmRWYWxpZCA9IGF3YWl0IHRoaXMuY29tcGFyZVBhc3N3b3JkKFxuICAgICAgY3VycmVudFBhc3N3b3JkLFxuICAgICAgdXNlci5wYXNzd29yZEhhc2gsXG4gICAgKTtcblxuICAgIGlmICghaXNDdXJyZW50UGFzc3dvcmRWYWxpZCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0RXhjZXB0aW9uKCdDdXJyZW50IHBhc3N3b3JkIGlzIGluY29ycmVjdCcpO1xuICAgIH1cblxuICAgIC8vIDMuIE5ldWVzIFBhc3N3b3J0IGhhc2hlbiB1bmQgc3BlaWNoZXJuXG4gICAgY29uc3QgbmV3UGFzc3dvcmRIYXNoID0gYXdhaXQgdGhpcy5oYXNoUGFzc3dvcmQobmV3UGFzc3dvcmQpO1xuICAgIGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LnVwZGF0ZVBhc3N3b3JkKGlkLCBuZXdQYXNzd29yZEhhc2gpO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKGBQYXNzd29yZCBjaGFuZ2VkIGZvciB1c2VyOiAke2lkfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEzDtnNjaHQgVXNlclxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBVVUlEIGRlcyBVc2Vyc1xuICAgKiBAcmV0dXJucyB0cnVlIHdlbm4gZXJmb2xncmVpY2hcbiAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiB3ZW5uIFVzZXIgbmljaHQgZXhpc3RpZXJ0XG4gICAqL1xuICBhc3luYyBkZWxldGUoaWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBEZWxldGluZyB1c2VyOiAke2lkfWApO1xuXG4gICAgY29uc3QgZGVsZXRlZCA9IGF3YWl0IHRoaXMudXNlcnNSZXBvc2l0b3J5LmRlbGV0ZShpZCk7XG5cbiAgICBpZiAoIWRlbGV0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbihgVXNlciB3aXRoIElEICR7aWR9IG5vdCBmb3VuZGApO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhgVXNlciBkZWxldGVkOiAke2lkfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFZBTElEQVRJT04gSEVMUEVSUyAoZsO8ciBBdXRoU2VydmljZSlcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIFZhbGlkaWVydCBVc2VyLUNyZWRlbnRpYWxzXG4gICAqIFZlcndlbmRldCBiZWkgTG9naW5cbiAgICpcbiAgICogU0VDVVJJVFk6XG4gICAqIC0gR2lidCBudWxsIHp1csO8Y2sgYmVpIEpFREVNIEZlaGxlciAoRW1haWwgbmljaHQgZ2VmdW5kZW4gT0RFUiBQYXNzd29yZCBmYWxzY2gpXG4gICAqIC0gVmVyaGluZGVydCBVc2VyIEVudW1lcmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsLUFkcmVzc2VcbiAgICogQHBhcmFtIHBhc3N3b3JkIC0gS2xhcnRleHQtUGFzc3dvcnRcbiAgICogQHJldHVybnMgU2FmZVVzZXIgd2VubiB2YWxpZGUsIG51bGwgd2VubiBuaWNodFxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVDcmVkZW50aWFscyhcbiAgICBlbWFpbDogc3RyaW5nLFxuICAgIHBhc3N3b3JkOiBzdHJpbmcsXG4gICk6IFByb21pc2U8U2FmZVVzZXIgfCBudWxsPiB7XG4gICAgLy8gMS4gVXNlciBsYWRlbiAobWl0IHBhc3N3b3JkSGFzaClcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5maW5kQnlFbWFpbFdpdGhQYXNzd29yZChlbWFpbCk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIC8vIFVzZXIgbmljaHQgZ2VmdW5kZW4gLSBhYmVyIHdpciB2ZXJyYXRlbiBkYXMgbmljaHQhXG4gICAgICAvLyBTdGF0dGRlc3NlbiBmw7xocmVuIHdpciB0cm90emRlbSBlaW5lbiBIYXNoLVZlcmdsZWljaCBkdXJjaFxuICAgICAgLy8gKHZlcmhpbmRlcnQgVGltaW5nLUF0dGFja3MpXG4gICAgICAvLyBSZWFsIGJjcnlwdCBoYXNoICgxMCByb3VuZHMpIGZvciBjb25zaXN0ZW50IHRpbWluZyBjaGFyYWN0ZXJpc3RpY3NcbiAgICAgIGF3YWl0IHRoaXMuY29tcGFyZVBhc3N3b3JkKFxuICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgJyQyYiQxMCR0ZmltM0FVeVlKSi5iMUNqejRqVW4uTko0SmlDTUNKWVM3Rm90cnBBS09BazJyNnJqclFEZScsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gMi4gUGFzc3dvcmQgdmVyZ2xlaWNoZW5cbiAgICBjb25zdCBpc1Bhc3N3b3JkVmFsaWQgPSBhd2FpdCB0aGlzLmNvbXBhcmVQYXNzd29yZChcbiAgICAgIHBhc3N3b3JkLFxuICAgICAgdXNlci5wYXNzd29yZEhhc2gsXG4gICAgKTtcblxuICAgIGlmICghaXNQYXNzd29yZFZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyAzLiBTYWZlVXNlciB6dXLDvGNrZ2ViZW4gKG9obmUgcGFzc3dvcmRIYXNoISlcbiAgICByZXR1cm4gdG9TYWZlVXNlcih1c2VyKTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9