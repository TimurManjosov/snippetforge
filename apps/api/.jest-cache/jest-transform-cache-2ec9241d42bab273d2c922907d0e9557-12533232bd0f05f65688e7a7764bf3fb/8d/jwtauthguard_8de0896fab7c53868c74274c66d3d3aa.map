{"file":"/home/runner/work/snippetforge/snippetforge/apps/api/src/modules/auth/guards/jwt-auth.guard.ts","mappings":";AAAA,4CAA4C;;;;;;;;;;;;;;AAE5C,2CAKwB;AACxB,uCAAyC;AACzC,+CAA6C;AAC7C,qEAA+D;AAE/D;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AAEI,IAAM,YAAY,oBAAlB,MAAM,YAAa,SAAQ,IAAA,oBAAS,EAAC,KAAK,CAAC;IAG5B;IAFH,MAAM,GAAG,IAAI,eAAM,CAAC,cAAY,CAAC,IAAI,CAAC,CAAC;IAExD,YAAoB,SAAoB;QACtC,KAAK,EAAE,CAAC;QADU,cAAS,GAAT,SAAS,CAAW;IAExC,CAAC;IAED;;;;;OAKG;IACH,WAAW,CAAC,OAAyB;QACnC,+CAA+C;QAC/C,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAU,gCAAa,EAAE;YACxE,OAAO,CAAC,UAAU,EAAE,EAAE,kCAAkC;YACxD,OAAO,CAAC,QAAQ,EAAE,EAAE,wCAAwC;SAC7D,CAAC,CAAC;QAEH,wDAAwD;QACxD,IAAI,QAAQ,EAAE,CAAC;YACb,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,gDAAgD,CAAC,CAAC;YACpE,OAAO,IAAI,CAAC;QACd,CAAC;QAED,wDAAwD;QACxD,OAAO,KAAK,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IACpC,CAAC;IAED;;;;;;;;;;;OAWG;IACH,aAAa,CAAI,GAAiB,EAAE,IAAO,EAAE,IAAuB;QAClE,0CAA0C;QAC1C,IAAI,GAAG,EAAE,CAAC;YACR,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,yBAAyB,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;YACzD,MAAM,IAAI,8BAAqB,CAAC,uBAAuB,CAAC,CAAC;QAC3D,CAAC;QAED,6DAA6D;QAC7D,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,OAAO,GACX,IAAI,EAAE,OAAO,IAAI,yCAAyC,CAAC;YAC7D,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,0BAA0B,OAAO,EAAE,CAAC,CAAC;YACtD,MAAM,IAAI,8BAAqB,CAAC,OAAO,CAAC,CAAC;QAC3C,CAAC;QAED,OAAO,IAAI,CAAC;IACd,CAAC;CACF,CAAA;AA3DY,oCAAY;uBAAZ,YAAY;IADxB,IAAA,mBAAU,GAAE;yDAIoB,gBAAS,oBAAT,gBAAS;GAH7B,YAAY,CA2DxB","names":[],"sources":["/home/runner/work/snippetforge/snippetforge/apps/api/src/modules/auth/guards/jwt-auth.guard.ts"],"sourcesContent":["// src/modules/auth/guards/jwt-auth.guard.ts\n\nimport {\n  ExecutionContext,\n  Injectable,\n  Logger,\n  UnauthorizedException,\n} from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { AuthGuard } from '@nestjs/passport';\nimport { IS_PUBLIC_KEY } from '../decorators/public.decorator';\n\n/**\n * JwtAuthGuard - Schützt Routes vor unauthentifizierten Zugriffen\n *\n * WIE ES FUNKTIONIERT:\n * 1. Guard wird auf Route/Controller angewendet\n * 2. canActivate() wird aufgerufen\n * 3. Prüft ob Route @Public() ist → Wenn ja, erlauben\n * 4. Wenn nicht public, delegiert an Passport JwtStrategy\n * 5. JwtStrategy validiert Token und lädt User\n * 6. Wenn erfolgreich:  request.user = User, Route wird ausgeführt\n * 7. Wenn fehlgeschlagen: 401 Unauthorized\n *\n * VERWENDUNG:\n *\n * // Auf einzelner Route\n * @UseGuards(JwtAuthGuard)\n * @Get('profile')\n * getProfile() {}\n *\n * // Global auf allen Routes (in main.ts)\n * app.useGlobalGuards(new JwtAuthGuard(reflector))\n *\n * // Route von Auth ausnehmen\n * @Public()\n * @Get('health')\n * healthCheck() {}\n */\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  private readonly logger = new Logger(JwtAuthGuard.name);\n\n  constructor(private reflector: Reflector) {\n    super();\n  }\n\n  /**\n   * canActivate - Entscheidet ob Request durchgelassen wird\n   *\n   * @param context - Execution Context (enthält Request, Handler, etc.)\n   * @returns true wenn erlaubt, false/Exception wenn nicht\n   */\n  canActivate(context: ExecutionContext) {\n    // 1. Prüfe ob Route als @Public() markiert ist\n    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [\n      context.getHandler(), // Methode (@Public() auf Methode)\n      context.getClass(), // Controller (@Public() auf Controller)\n    ]);\n\n    // 2. Wenn public, sofort erlauben (keine Token-Prüfung)\n    if (isPublic) {\n      this.logger.debug('Public route accessed, skipping authentication');\n      return true;\n    }\n\n    // 3. Wenn nicht public, Passport JWT Strategy ausführen\n    return super.canActivate(context);\n  }\n\n  /**\n   * handleRequest - Verarbeitet Passport-Ergebnis\n   *\n   * Wird nach JwtStrategy.validate() aufgerufen\n   * Erlaubt uns, den Error/User zu customizen\n   *\n   * @param err - Error von Passport (null wenn erfolgreich)\n   * @param user - User von JwtStrategy. validate() (undefined wenn fehlgeschlagen)\n   * @param info - Zusätzliche Info (z.B. \"jwt expired\")\n   * @returns User wenn erfolgreich\n   * @throws UnauthorizedException wenn fehlgeschlagen\n   */\n  handleRequest<T>(err: Error | null, user: T, info: Error | undefined): T {\n    // Passport Error (z.B. invalid signature)\n    if (err) {\n      this.logger.warn(`Authentication error: ${err.message}`);\n      throw new UnauthorizedException('Authentication failed');\n    }\n\n    // Kein User (Token invalid/expired oder User nicht gefunden)\n    if (!user) {\n      const message =\n        info?.message || 'Invalid or missing authentication token';\n      this.logger.warn(`Authentication failed: ${message}`);\n      throw new UnauthorizedException(message);\n    }\n\n    return user;\n  }\n}\n"],"version":3}