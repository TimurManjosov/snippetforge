a390d4b780700c5f8ad5556f39befa2f
"use strict";
// src/modules/users/users.repository.ts
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UsersRepository_1;
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsersRepository = void 0;
const common_1 = require("@nestjs/common");
const drizzle_orm_1 = require("drizzle-orm");
const schema_1 = require("../../lib/db/schema");
const database_1 = require("../../shared/database");
/**
 * UsersRepository - Data Access Layer für User-Entity
 *
 * VERANTWORTLICHKEITEN (Single Responsibility):
 * - Alle Datenbank-Queries für Users
 * - Keine Business Logic (kein Hashing, keine Validation)
 * - Keine HTTP-Concerns (keine Exceptions werfen)
 *
 * WARUM Repository Pattern?
 * 1. Testbarkeit: Repository kann gemockt werden
 * 2. Austauschbarkeit: DB-Wechsel betrifft nur Repository
 * 3. Klarheit: Service enthält nur Business Logic
 *
 * RETURN VALUES:
 * - Gefunden: User-Objekt
 * - Nicht gefunden: null (NICHT undefined!)
 * - Fehler: Exception wird geworfen (DB-Errors)
 */
let UsersRepository = UsersRepository_1 = class UsersRepository {
    db;
    logger = new common_1.Logger(UsersRepository_1.name);
    constructor(db) {
        this.db = db;
    }
    /**
     * Findet User anhand der ID
     *
     * @param id - UUID des Users
     * @returns User oder null wenn nicht gefunden
     */
    async findById(id) {
        this.logger.debug(`Finding user by ID: ${id}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.eq)(schema_1.users.id, id),
        });
        return result ?? null;
    }
    /**
     * Findet User anhand der Email
     * Verwendet für Login und Email-Uniqueness-Check
     *
     * @param email - Email-Adresse (case-insensitive durch DB)
     * @returns User oder null wenn nicht gefunden
     */
    async findByEmail(email) {
        this.logger.debug(`Finding user by email: ${email}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.eq)(schema_1.users.email, email.toLowerCase()),
        });
        return result ?? null;
    }
    /**
     * Findet User anhand des Usernamens
     * Verwendet für Username-Uniqueness-Check
     *
     * @param username - Username (case-sensitive)
     * @returns User oder null wenn nicht gefunden
     */
    async findByUsername(username) {
        this.logger.debug(`Finding user by username: ${username}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.eq)(schema_1.users.username, username),
        });
        return result ?? null;
    }
    /**
     * Prüft ob Email ODER Username bereits existieren
     * Verwendet bei Registration um Duplikate zu verhindern
     *
     * @param email - Email zu prüfen
     * @param username - Username zu prüfen
     * @returns User wenn einer existiert, sonst null
     */
    async findByEmailOrUsername(email, username) {
        this.logger.debug(`Checking if email or username exists: ${email}, ${username}`);
        const result = await this.db.drizzle.query.users.findFirst({
            where: (0, drizzle_orm_1.or)((0, drizzle_orm_1.eq)(schema_1.users.email, email.toLowerCase()), (0, drizzle_orm_1.eq)(schema_1.users.username, username)),
        });
        return result ?? null;
    }
    /**
     * Erstellt neuen User in der Datenbank
     *
     * WICHTIG:
     * - data.passwordHash muss BEREITS gehasht sein!
     * - Email wird automatisch lowercase gespeichert
     *
     * @param data - User-Daten (mit passwordHash, NICHT password!)
     * @returns Erstellter User
     * @throws Bei Constraint-Violation (Duplicate Email/Username)
     */
    async create(data) {
        this.logger.debug(`Creating new user: ${data.email}`);
        const [newUser] = await this.db.drizzle
            .insert(schema_1.users)
            .values({
            ...data,
            email: data.email.toLowerCase(), // Normalisierung
        })
            .returning();
        this.logger.log(`User created successfully: ${newUser.id}`);
        return newUser;
    }
    /**
     * Aktualisiert User-Daten
     *
     * @param id - UUID des Users
     * @param data - Zu aktualisierende Felder
     * @returns Aktualisierter User oder null wenn nicht gefunden
     */
    async update(id, data) {
        this.logger.debug(`Updating user: ${id}`);
        const [updatedUser] = await this.db.drizzle
            .update(schema_1.users)
            .set({
            ...data,
            updatedAt: new Date(), // Timestamp aktualisieren
        })
            .where((0, drizzle_orm_1.eq)(schema_1.users.id, id))
            .returning();
        if (!updatedUser) {
            this.logger.warn(`User not found for update: ${id}`);
            return null;
        }
        this.logger.log(`User updated successfully: ${id}`);
        return updatedUser;
    }
    /**
     * Aktualisiert nur das Passwort eines Users
     * Separatiert von update() für Klarheit und Audit-Logging
     *
     * @param id - UUID des Users
     * @param passwordHash - Neuer Password Hash (BEREITS gehasht!)
     * @returns true wenn erfolgreich, false wenn User nicht gefunden
     */
    async updatePassword(id, passwordHash) {
        this.logger.debug(`Updating password for user: ${id}`);
        const result = await this.db.drizzle
            .update(schema_1.users)
            .set({
            passwordHash,
            updatedAt: new Date(),
        })
            .where((0, drizzle_orm_1.eq)(schema_1.users.id, id))
            .returning({ id: schema_1.users.id });
        if (result.length === 0) {
            this.logger.warn(`User not found for password update: ${id}`);
            return false;
        }
        this.logger.log(`Password updated successfully for user: ${id}`);
        return true;
    }
    /**
     * Löscht User (Hard Delete)
     *
     * WARNUNG: In Production besser Soft Delete verwenden!
     * (isDeleted Flag statt echtem Löschen)
     *
     * @param id - UUID des Users
     * @returns true wenn gelöscht, false wenn nicht gefunden
     */
    async delete(id) {
        this.logger.debug(`Deleting user: ${id}`);
        const result = await this.db.drizzle
            .delete(schema_1.users)
            .where((0, drizzle_orm_1.eq)(schema_1.users.id, id))
            .returning({ id: schema_1.users.id });
        if (result.length === 0) {
            this.logger.warn(`User not found for deletion: ${id}`);
            return false;
        }
        this.logger.log(`User deleted successfully: ${id}`);
        return true;
    }
    /**
     * Zählt alle User (für Admin-Dashboard)
     *
     * @returns Anzahl der User
     */
    async count() {
        const result = await this.db.drizzle
            .select({ count: schema_1.users.id })
            .from(schema_1.users);
        // Drizzle gibt Array zurück, wir brauchen Länge
        return result.length;
    }
};
exports.UsersRepository = UsersRepository;
exports.UsersRepository = UsersRepository = UsersRepository_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [typeof (_a = typeof database_1.DatabaseService !== "undefined" && database_1.DatabaseService) === "function" ? _a : Object])
], UsersRepository);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvcnVubmVyL3dvcmsvc25pcHBldGZvcmdlL3NuaXBwZXRmb3JnZS9hcHBzL2FwaS9zcmMvbW9kdWxlcy91c2Vycy91c2Vycy5yZXBvc2l0b3J5LnRzIiwibWFwcGluZ3MiOiI7QUFBQSx3Q0FBd0M7Ozs7Ozs7Ozs7Ozs7O0FBRXhDLDJDQUFvRDtBQUNwRCw2Q0FBcUM7QUFDckMsZ0RBQXFFO0FBQ3JFLG9EQUF3RDtBQUV4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFFSSxJQUFNLGVBQWUsdUJBQXJCLE1BQU0sZUFBZTtJQUdHO0lBRlosTUFBTSxHQUFHLElBQUksZUFBTSxDQUFDLGlCQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFM0QsWUFBNkIsRUFBbUI7UUFBbkIsT0FBRSxHQUFGLEVBQUUsQ0FBaUI7SUFBRyxDQUFDO0lBRXBEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFVO1FBQ3ZCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRS9DLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7WUFDekQsS0FBSyxFQUFFLElBQUEsZ0JBQUUsRUFBQyxjQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQztTQUN4QixDQUFDLENBQUM7UUFFSCxPQUFPLE1BQU0sSUFBSSxJQUFJLENBQUM7SUFDeEIsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsS0FBYTtRQUM3QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUVyRCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO1lBQ3pELEtBQUssRUFBRSxJQUFBLGdCQUFF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QUEsZ0JBQUUsRUFBQyxjQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZCLFNBQVMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxjQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUUvQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0NBQWdDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdkQsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsOEJBQThCLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxLQUFLO1FBQ1QsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU87YUFDakMsTUFBTSxDQUFDLEVBQUUsS0FBSyxFQUFFLGNBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQzthQUMzQixJQUFJLENBQUMsY0FBSyxDQUFDLENBQUM7UUFFZixnREFBZ0Q7UUFDaEQsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7Q0FDRixDQUFBO0FBM01ZLDBDQUFlOzBCQUFmLGVBQWU7SUFEM0IsSUFBQSxtQkFBVSxHQUFFO3lEQUlzQiwwQkFBZSxvQkFBZiwwQkFBZTtHQUhyQyxlQUFlLENBMk0zQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvaG9tZS9ydW5uZXIvd29yay9zbmlwcGV0Zm9yZ2Uvc25pcHBldGZvcmdlL2FwcHMvYXBpL3NyYy9tb2R1bGVzL3VzZXJzL3VzZXJzLnJlcG9zaXRvcnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL21vZHVsZXMvdXNlcnMvdXNlcnMucmVwb3NpdG9yeS50c1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBMb2dnZXIgfSBmcm9tICdAbmVzdGpzL2NvbW1vbic7XG5pbXBvcnQgeyBlcSwgb3IgfSBmcm9tICdkcml6emxlLW9ybSc7XG5pbXBvcnQgeyB1c2VycywgdHlwZSBOZXdVc2VyLCB0eXBlIFVzZXIgfSBmcm9tICcuLi8uLi9saWIvZGIvc2NoZW1hJztcbmltcG9ydCB7IERhdGFiYXNlU2VydmljZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9kYXRhYmFzZSc7XG5cbi8qKlxuICogVXNlcnNSZXBvc2l0b3J5IC0gRGF0YSBBY2Nlc3MgTGF5ZXIgZsO8ciBVc2VyLUVudGl0eVxuICpcbiAqIFZFUkFOVFdPUlRMSUNIS0VJVEVOIChTaW5nbGUgUmVzcG9uc2liaWxpdHkpOlxuICogLSBBbGxlIERhdGVuYmFuay1RdWVyaWVzIGbDvHIgVXNlcnNcbiAqIC0gS2VpbmUgQnVzaW5lc3MgTG9naWMgKGtlaW4gSGFzaGluZywga2VpbmUgVmFsaWRhdGlvbilcbiAqIC0gS2VpbmUgSFRUUC1Db25jZXJucyAoa2VpbmUgRXhjZXB0aW9ucyB3ZXJmZW4pXG4gKlxuICogV0FSVU0gUmVwb3NpdG9yeSBQYXR0ZXJuP1xuICogMS4gVGVzdGJhcmtlaXQ6IFJlcG9zaXRvcnkga2FubiBnZW1vY2t0IHdlcmRlblxuICogMi4gQXVzdGF1c2NoYmFya2VpdDogREItV2VjaHNlbCBiZXRyaWZmdCBudXIgUmVwb3NpdG9yeVxuICogMy4gS2xhcmhlaXQ6IFNlcnZpY2UgZW50aMOkbHQgbnVyIEJ1c2luZXNzIExvZ2ljXG4gKlxuICogUkVUVVJOIFZBTFVFUzpcbiAqIC0gR2VmdW5kZW46IFVzZXItT2JqZWt0XG4gKiAtIE5pY2h0IGdlZnVuZGVuOiBudWxsIChOSUNIVCB1bmRlZmluZWQhKVxuICogLSBGZWhsZXI6IEV4Y2VwdGlvbiB3aXJkIGdld29yZmVuIChEQi1FcnJvcnMpXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBVc2Vyc1JlcG9zaXRvcnkge1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ2dlciA9IG5ldyBMb2dnZXIoVXNlcnNSZXBvc2l0b3J5Lm5hbWUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZGI6IERhdGFiYXNlU2VydmljZSkge31cblxuICAvKipcbiAgICogRmluZGV0IFVzZXIgYW5oYW5kIGRlciBJRFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBVVUlEIGRlcyBVc2Vyc1xuICAgKiBAcmV0dXJucyBVc2VyIG9kZXIgbnVsbCB3ZW5uIG5pY2h0IGdlZnVuZGVuXG4gICAqL1xuICBhc3luYyBmaW5kQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBGaW5kaW5nIHVzZXIgYnkgSUQ6ICR7aWR9YCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGUucXVlcnkudXNlcnMuZmluZEZpcnN0KHtcbiAgICAgIHdoZXJlOiBlcSh1c2Vycy5pZCwgaWQpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdCA/PyBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRldCBVc2VyIGFuaGFuZCBkZXIgRW1haWxcbiAgICogVmVyd2VuZGV0IGbDvHIgTG9naW4gdW5kIEVtYWlsLVVuaXF1ZW5lc3MtQ2hlY2tcbiAgICpcbiAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwtQWRyZXNzZSAoY2FzZS1pbnNlbnNpdGl2ZSBkdXJjaCBEQilcbiAgICogQHJldHVybnMgVXNlciBvZGVyIG51bGwgd2VubiBuaWNodCBnZWZ1bmRlblxuICAgKi9cbiAgYXN5bmMgZmluZEJ5RW1haWwoZW1haWw6IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmluZGluZyB1c2VyIGJ5IGVtYWlsOiAke2VtYWlsfWApO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kYi5kcml6emxlLnF1ZXJ5LnVzZXJzLmZpbmRGaXJzdCh7XG4gICAgICB3aGVyZTogZXEodXNlcnMuZW1haWwsIGVtYWlsLnRvTG93ZXJDYXNlKCkpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdCA/PyBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRldCBVc2VyIGFuaGFuZCBkZXMgVXNlcm5hbWVuc1xuICAgKiBWZXJ3ZW5kZXQgZsO8ciBVc2VybmFtZS1VbmlxdWVuZXNzLUNoZWNrXG4gICAqXG4gICAqIEBwYXJhbSB1c2VybmFtZSAtIFVzZXJuYW1lIChjYXNlLXNlbnNpdGl2ZSlcbiAgICogQHJldHVybnMgVXNlciBvZGVyIG51bGwgd2VubiBuaWNodCBnZWZ1bmRlblxuICAgKi9cbiAgYXN5bmMgZmluZEJ5VXNlcm5hbWUodXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRmluZGluZyB1c2VyIGJ5IHVzZXJuYW1lOiAke3VzZXJuYW1lfWApO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kYi5kcml6emxlLnF1ZXJ5LnVzZXJzLmZpbmRGaXJzdCh7XG4gICAgICB3aGVyZTogZXEodXNlcnMudXNlcm5hbWUsIHVzZXJuYW1lKSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQgPz8gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcsO8ZnQgb2IgRW1haWwgT0RFUiBVc2VybmFtZSBiZXJlaXRzIGV4aXN0aWVyZW5cbiAgICogVmVyd2VuZGV0IGJlaSBSZWdpc3RyYXRpb24gdW0gRHVwbGlrYXRlIHp1IHZlcmhpbmRlcm5cbiAgICpcbiAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwgenUgcHLDvGZlblxuICAgKiBAcGFyYW0gdXNlcm5hbWUgLSBVc2VybmFtZSB6dSBwcsO8ZmVuXG4gICAqIEByZXR1cm5zIFVzZXIgd2VubiBlaW5lciBleGlzdGllcnQsIHNvbnN0IG51bGxcbiAgICovXG4gIGFzeW5jIGZpbmRCeUVtYWlsT3JVc2VybmFtZShcbiAgICBlbWFpbDogc3RyaW5nLFxuICAgIHVzZXJuYW1lOiBzdHJpbmcsXG4gICk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBDaGVja2luZyBpZiBlbWFpbCBvciB1c2VybmFtZSBleGlzdHM6ICR7ZW1haWx9LCAke3VzZXJuYW1lfWAsXG4gICAgKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGIuZHJpenpsZS5xdWVyeS51c2Vycy5maW5kRmlyc3Qoe1xuICAgICAgd2hlcmU6IG9yKFxuICAgICAgICBlcSh1c2Vycy5lbWFpbCwgZW1haWwudG9Mb3dlckNhc2UoKSksXG4gICAgICAgIGVxKHVzZXJzLnVzZXJuYW1lLCB1c2VybmFtZSksXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdCA/PyBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEVyc3RlbGx0IG5ldWVuIFVzZXIgaW4gZGVyIERhdGVuYmFua1xuICAgKlxuICAgKiBXSUNIVElHOlxuICAgKiAtIGRhdGEucGFzc3dvcmRIYXNoIG11c3MgQkVSRUlUUyBnZWhhc2h0IHNlaW4hXG4gICAqIC0gRW1haWwgd2lyZCBhdXRvbWF0aXNjaCBsb3dlcmNhc2UgZ2VzcGVpY2hlcnRcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBVc2VyLURhdGVuIChtaXQgcGFzc3dvcmRIYXNoLCBOSUNIVCBwYXNzd29yZCEpXG4gICAqIEByZXR1cm5zIEVyc3RlbGx0ZXIgVXNlclxuICAgKiBAdGhyb3dzIEJlaSBDb25zdHJhaW50LVZpb2xhdGlvbiAoRHVwbGljYXRlIEVtYWlsL1VzZXJuYW1lKVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlKGRhdGE6IE5ld1VzZXIpOiBQcm9taXNlPFVzZXI+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgQ3JlYXRpbmcgbmV3IHVzZXI6ICR7ZGF0YS5lbWFpbH1gKTtcblxuICAgIGNvbnN0IFtuZXdVc2VyXSA9IGF3YWl0IHRoaXMuZGIuZHJpenpsZVxuICAgICAgLmluc2VydCh1c2VycylcbiAgICAgIC52YWx1ZXMoe1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBlbWFpbDogZGF0YS5lbWFpbC50b0xvd2VyQ2FzZSgpLCAvLyBOb3JtYWxpc2llcnVuZ1xuICAgICAgfSlcbiAgICAgIC5yZXR1cm5pbmcoKTtcblxuICAgIHRoaXMubG9nZ2VyLmxvZyhgVXNlciBjcmVhdGVkIHN1Y2Nlc3NmdWxseTogJHtuZXdVc2VyLmlkfWApO1xuICAgIHJldHVybiBuZXdVc2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIEFrdHVhbGlzaWVydCBVc2VyLURhdGVuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFVVSUQgZGVzIFVzZXJzXG4gICAqIEBwYXJhbSBkYXRhIC0gWnUgYWt0dWFsaXNpZXJlbmRlIEZlbGRlclxuICAgKiBAcmV0dXJucyBBa3R1YWxpc2llcnRlciBVc2VyIG9kZXIgbnVsbCB3ZW5uIG5pY2h0IGdlZnVuZGVuXG4gICAqL1xuICBhc3luYyB1cGRhdGUoaWQ6IHN0cmluZywgZGF0YTogUGFydGlhbDxOZXdVc2VyPik6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgVXBkYXRpbmcgdXNlcjogJHtpZH1gKTtcblxuICAgIGNvbnN0IFt1cGRhdGVkVXNlcl0gPSBhd2FpdCB0aGlzLmRiLmRyaXp6bGVcbiAgICAgIC51cGRhdGUodXNlcnMpXG4gICAgICAuc2V0KHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLCAvLyBUaW1lc3RhbXAgYWt0dWFsaXNpZXJlblxuICAgICAgfSlcbiAgICAgIC53aGVyZShlcSh1c2Vycy5pZCwgaWQpKVxuICAgICAgLnJldHVybmluZygpO1xuXG4gICAgaWYgKCF1cGRhdGVkVXNlcikge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgVXNlciBub3QgZm91bmQgZm9yIHVwZGF0ZTogJHtpZH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmxvZyhgVXNlciB1cGRhdGVkIHN1Y2Nlc3NmdWxseTogJHtpZH1gKTtcbiAgICByZXR1cm4gdXBkYXRlZFVzZXI7XG4gIH1cblxuICAvKipcbiAgICogQWt0dWFsaXNpZXJ0IG51ciBkYXMgUGFzc3dvcnQgZWluZXMgVXNlcnNcbiAgICogU2VwYXJhdGllcnQgdm9uIHVwZGF0ZSgpIGbDvHIgS2xhcmhlaXQgdW5kIEF1ZGl0LUxvZ2dpbmdcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVVVJRCBkZXMgVXNlcnNcbiAgICogQHBhcmFtIHBhc3N3b3JkSGFzaCAtIE5ldWVyIFBhc3N3b3JkIEhhc2ggKEJFUkVJVFMgZ2VoYXNodCEpXG4gICAqIEByZXR1cm5zIHRydWUgd2VubiBlcmZvbGdyZWljaCwgZmFsc2Ugd2VubiBVc2VyIG5pY2h0IGdlZnVuZGVuXG4gICAqL1xuICBhc3luYyB1cGRhdGVQYXNzd29yZChpZDogc3RyaW5nLCBwYXNzd29yZEhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKGBVcGRhdGluZyBwYXNzd29yZCBmb3IgdXNlcjogJHtpZH1gKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGIuZHJpenpsZVxuICAgICAgLnVwZGF0ZSh1c2VycylcbiAgICAgIC5zZXQoe1xuICAgICAgICBwYXNzd29yZEhhc2gsXG4gICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgIH0pXG4gICAgICAud2hlcmUoZXEodXNlcnMuaWQsIGlkKSlcbiAgICAgIC5yZXR1cm5pbmcoeyBpZDogdXNlcnMuaWQgfSk7XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihgVXNlciBub3QgZm91bmQgZm9yIHBhc3N3b3JkIHVwZGF0ZTogJHtpZH1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coYFBhc3N3b3JkIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5IGZvciB1c2VyOiAke2lkfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEzDtnNjaHQgVXNlciAoSGFyZCBEZWxldGUpXG4gICAqXG4gICAqIFdBUk5VTkc6IEluIFByb2R1Y3Rpb24gYmVzc2VyIFNvZnQgRGVsZXRlIHZlcndlbmRlbiFcbiAgICogKGlzRGVsZXRlZCBGbGFnIHN0YXR0IGVjaHRlbSBMw7ZzY2hlbilcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVVVJRCBkZXMgVXNlcnNcbiAgICogQHJldHVybnMgdHJ1ZSB3ZW5uIGdlbMO2c2NodCwgZmFsc2Ugd2VubiBuaWNodCBnZWZ1bmRlblxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhgRGVsZXRpbmcgdXNlcjogJHtpZH1gKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZGIuZHJpenpsZVxuICAgICAgLmRlbGV0ZSh1c2VycylcbiAgICAgIC53aGVyZShlcSh1c2Vycy5pZCwgaWQpKVxuICAgICAgLnJldHVybmluZyh7IGlkOiB1c2Vycy5pZCB9KTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKGBVc2VyIG5vdCBmb3VuZCBmb3IgZGVsZXRpb246ICR7aWR9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIubG9nKGBVc2VyIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5OiAke2lkfWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFrDpGhsdCBhbGxlIFVzZXIgKGbDvHIgQWRtaW4tRGFzaGJvYXJkKVxuICAgKlxuICAgKiBAcmV0dXJucyBBbnphaGwgZGVyIFVzZXJcbiAgICovXG4gIGFzeW5jIGNvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5kYi5kcml6emxlXG4gICAgICAuc2VsZWN0KHsgY291bnQ6IHVzZXJzLmlkIH0pXG4gICAgICAuZnJvbSh1c2Vycyk7XG5cbiAgICAvLyBEcml6emxlIGdpYnQgQXJyYXkgenVyw7xjaywgd2lyIGJyYXVjaGVuIEzDpG5nZVxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoO1xuICB9XG59XG4iXSwidmVyc2lvbiI6M30=